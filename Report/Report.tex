\documentclass{turabian-researchpaper}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{amsmath, amssymb, amsfonts} % For math equations
\usepackage{csquotes, ellipsis}
\usepackage[scaled=0.85]{beramono}
\usepackage{xcolor}     % For code coloring
\usepackage[numbered,framed]{matlab-prettifier} 
\usepackage{listings}   % For code snippets
\lstset{
	inputencoding=utf8,
	extendedchars=true,
	literate={θ}{{$\theta$}}1
}
\usepackage{graphicx}   % For images
\usepackage{float}      % For figure placement

\usepackage{pdflscape}

\usepackage[notes, backend=biber]{biblatex-chicago}
\addbibresource{works-cited.bib}

% Specify paper size
\usepackage[pass, letterpaper]{geometry}

% Code Listing Style Definition
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}
\lstdefinestyle{myMatlabStyle}{
	backgroundcolor=\color{backcolour},   % Your light beige background
	commentstyle=\color{codegreen},       % Your green comments
	keywordstyle=\color{blue},            % Standard blue keywords
	numberstyle=\tiny\color{codegray},    % Gray line numbers
	stringstyle=\color{codepurple},       % Purple strings
	basicstyle=\ttfamily\footnotesize,    % Monospace font
	breaklines=true,                 
	captionpos=b,                    
	keepspaces=true,                 
	numbers=left,                    
	numbersep=5pt,                  
	showspaces=false,                
	showstringspaces=false,
	showtabs=false,                  
	tabsize=2,
	language=Matlab                       % Enforce Matlab syntax highlighting
}

% --- Title Page Setup ---
\title{Planar Quadrotor}
\subtitle{Extended Kalman Filter Design}
\author{Arseni Lysak, Tsimafei Iliusenka, John Elvin Ndahiro, Pablo Calderon Mateo}

\course{Aeronautical Systems Integration}

\date{\today}

\begin{document}
	\maketitle
	
	\section{Introduction}
	
	The aim of this project is to implement an Extended Kalman Filter (EKF) to estimate the movement of a 2D planar quadrotor (fig. \ref{fig:quadrotor_diagram}) utilizing noisy sensor measurements.
	 
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.8\textwidth]{Planar_Quadrotor.png}
		\caption{Diagram of the Planar Quadrotor System.}
		\label{fig:quadrotor_diagram}
	\end{figure}
	
	\section{System modeling}
	
	The movement of the quadrotor is governed by the following nonlinear equations of motion:

\begin{align}
	m\ddot{x} &= -(u_1 + u_2)\sin\theta \label{eq:x_dyn} \\
	m\ddot{y} &= (u_1 + u_2)\cos\theta - mg \label{eq:y_dyn} \\
	I\ddot{\theta} &= r(u_1 - u_2) \label{eq:theta_dyn}
\end{align}
	
	\noindent where:
	\begin{itemize}
		\item $m$: mass of the quadrotor
		\item $I$: moment of inertia
		\item $r$: distance from the center of mass to the rotors
		\item $g$: gravitational acceleration
		\item $u_1, u_2$: rotor thrust forces
	\end{itemize}
	
	This would imply that the system state is represented by a six-element vector $\mathbf{x}$, and the control input is represented by a two-element vector $\mathbf{u}$:

	\begin{equation}
		\mathbf{x} = 
		\begin{bmatrix}
			x \\ \dot{x} \\ y \\ \dot{y} \\ \theta \\ \dot{\theta}
		\end{bmatrix}, \quad
		\mathbf{u} = 
		\begin{bmatrix}
			u_1 \\ u_2
		\end{bmatrix}
	\end{equation}
	
	\section{Quadcopter definition}
	
	The quadrotor system parameters were initialized with a mass $m = 0.5 \text{ kg}$, a rotor arm length $r = 0.15 \text{ m}$, and a moment of inertia $I = 0.005 \text{ kg} \cdot \text{m}^2$. The simulation utilizes a time step of $dt = 0.01 \text{ s}$ under standard gravitational acceleration $g = 9.81 \text{ m/s}^2$2. The initial conditions for the simulation were set with an orientation angle $\theta = 0 \text{ rad}$, and baseline rotor thrust forces $u_1 = 5 \text{ N}$ and $u_2 = 5 \text{ N}$.
	
	Four scenarios for control inputs were chosen: 
	Tsimafei. Remember that there was a code snippet before, so your description should be pretty detailed, you can rely on the code when writing it
	
	A thrust generated by a rotor is inherently periodic and this is recreated using sine and cosine functions.
	
	Moreover, a unique set of initial conditions was defined for each case:
	Tsimafei, describe this as well.

    \section{Clean simulation}
	
	Equations \ref{eq:x_dyn}-\ref{eq:theta_dyn} represent perfect conditions as they do not account for process noise. The state vector for this ideal trajectory is designated as \texttt{state.clean} in the code. This ensures the prediction adheres to the actual physical dynamics.
	
	The clean simulation utilizes first-order Euler integration to propagate the system state forward in time. At each time step $t$, the state increments are computed based on the previous state vector $\mathbf{x}_{t-1}$ and the current control inputs 1. The positional and angular updates are derived linearly from the previous velocities:
	\begin{equation}
		\Delta x = \dot{x}_{t-1} \Delta t, \quad \Delta y = \dot{y}_{t-1} \Delta t, \quad \Delta \theta = \dot{\theta}_{t-1} \Delta t\label{eq:euler_kinematics}
	\end{equation}The changes in linear and angular velocities are calculated by discretizing the dynamic equations of motion (Eq.\ref{eq:x_dyn}-\ref{eq:theta_dyn}). These updates account for the non-linear coupling introduced by the quadrotor's orientation $\theta$:
	
	\begin{align}
		\Delta \dot{x} &= -\frac{(u_1 + u_2)}{m}\sin(\theta_{t-1}) \Delta t \label{eq:euler_dx} \\
		\Delta \dot{y} &= \left( \frac{(u_1 + u_2)}{m}\cos(\theta_{t-1}) - g \right) \Delta t \label{eq:euler_dy} \\
		\Delta \dot{\theta} &= \frac{r}{I}(u_1 - u_2) \Delta t \label{eq:euler_dtheta}
	\end{align}
	
	Finally, the state vector is updated by adding these increments to the previous state, $\mathbf{x}_t = \mathbf{x}_{t-1} + \Delta \mathbf{x}$, and the ideal sensor output is computed as $\mathbf{y}_t = C \mathbf{x}_t$.
	
	\section{Real-World Trajectory}
	
	The real-world trajectory (\texttt{state.real}) differs from the perfect trajectory solely through the introduction of process and measurement noise. Gaussian noise is utilized, with amplitudes selected as follows:
	
	\begin{lstlisting}[style=myMatlabStyle]
	noise_data.state_noise_amp = 0.003;
	noise_data.output_noise_amp = 0.01;
	\end{lstlisting}
	
	The governing equations \ref{eq:x_dyn}-\ref{eq:theta_dyn} remain unchanged, with noise injected during the state update step. The true state evolution is modeled by adding a stochastic process noise vector $\mathbf{w}$ to the deterministic dynamics:
	\begin{equation}
		\mathbf{x}_t = \mathbf{x}_{t-1} + \Delta \mathbf{x} + \mathbf{w}_{t-1}\label{eq:noisy_state_update}
	\end{equation}
	Subsequently, the simulated sensor measurements $\mathbf{z}_t$ are generated by applying the measurement matrix $C$ to the updated state, with the addition of measurement noise $\mathbf{v}_t$:
	\begin{equation}
		\mathbf{z}_t = C \mathbf{x}_t + \mathbf{v}_t\label{eq:noisy_measurement_update}
	\end{equation}
	
	\section{Extended Kalman Filter Design}
	
	The "default" Kalman filter addresses the general problem of trying to estimate the state of a discrete-time controlled process that is governed by a linear stochastic difference equation. A Kalman filter that linearizes about the current mean and covariance is referred to as an extended Kalman filter or EKF.
	
	The EKF is employed because the quadrotor system is nonlinear—motion is dependent on the sine and cosine of the angle $\theta$. The EKF linearizes the system at each time step using the current optimal estimate prior to applying standard Kalman update equations.
	
	The working principle of the filter is optimally weighting sensor measurements against the predicted values in accordance with the ideal mathematical model (fig. \ref{fig:ekfprinciple}).
		
	\begin{figure}
		\centering
		\includegraphics[width=1\linewidth]{ASI_EKFprinciple}
		\caption{A complete picture of the operation of the extended Kalman filter.}
		\label{fig:ekfprinciple}
	\end{figure}
	
	
	\subsection{Jacobian for Covariance Propagation}
	
	\noindent To estimate a process with non-linear difference and measurement relationships, it is possible to begin by writing new governing equations that linearize an estimate about the point k,
	\begin{align}
		x_k &\approx \tilde{x}_k + A(x_{k-1} - \hat{x}_{k-1}) + w_{k-1}, \label{eq:x_k}\\
		z_k &\approx \tilde{z}_k + H(x_k - \tilde{x}_k) + v_k \label{eq:z_k}
	\end{align}
	where
	\begin{itemize}
		\item $x_k$ and $z_k$ are the actual state and measurement vectors,
		\item $\tilde{x}_k$ and $\tilde{z}_k$ are the approximate state and measurement vectors
		\item $\hat{x}_k$ is an \textit{aposteriori} estimate of the state at step $k$,
		\item the random variables $w_k$ and $v_k$ represent the process and measurement noise
		\item $A$ is the Jacobian matrix of partial derivatives of $f$ with respect to $x$, that is
		\[
		A_{[i, j]} = \frac{\partial f_{[i]}}{\partial x_{[j]}}(\hat{x}_{k-1}, u_k, 0),
		\]
		\item $H$ is the Jacobian matrix of partial derivatives of $h$ with respect to $x$,
		\[
		H_{[i, j]} = \frac{\partial h_{[i]}}{\partial x_{[j]}}(\tilde{x}_k, 0),
		\]
	\end{itemize}
	
	
	The Extended Kalman Filter propagates uncertainty (covariance) by requiring a local linear approximation of the nonlinear dynamics in the form of matrices $A$ and $H$.
	
	To update the error covariance, the state transition Jacobian $A$ is derived from the partial derivatives of the dynamics, which are defined by equations \ref{eq:x_dyn} - \ref{eq:theta_dyn}:
	\begin{align}
		\frac{\partial \ddot{x}}{\partial \theta} = -\frac{\cos\theta}{m}(u_1 + u_2) \label{eq:partial_x} \\
		\frac{\partial \ddot{y}}{\partial \theta} = -\frac{\sin\theta}{m}(u_1 + u_2) \label{eq:partial_y}
	\end{align}

	
	The resulting Jacobian $A$ is:
	
	\begin{equation}
		A = \begin{bmatrix}
			0 & 1 & 0 & 0 & 0 & 0 \\
			0 & 0 & 0 & 0 & \frac{-\cos(\theta)(u_1+u_2)}{m} & 0 \\
			0 & 0 & 0 & 1 & 0 & 0 \\
			0 & 0 & 0 & 0 & \frac{-\sin(\theta)(u_1+u_2)}{m} & 0 \\
			0 & 0 & 0 & 0 & 0 & 1 \\
			0 & 0 & 0 & 0 & 0 & 0
		\end{bmatrix}
	\end{equation}
	
	The discrete-time state transition matrix $F$ used in the EKF is defined as $F = I + A \Delta t$, where $I$ represents the identity matrix and $A \Delta t$ represents the change over the time step.
	
	\begin{equation}
		F = \begin{bmatrix} 
			1 & \Delta t & 0 & 0 & 0 & 0 \\
			0 & 1 & 0 & 0 & \frac{-\cos(\theta)(u_1+u_2)}{m} \Delta t & 0 \\
			0 & 0 & 1 & \Delta t & 0 & 0 \\
			0 & 0 & 0 & 1 & \frac{-\sin(\theta)(u_1+u_2)}{m} \Delta t & 0 \\
			0 & 0 & 0 & 0 & 1 & \Delta t \\
			0 & 0 & 0 & 0 & 0 & 1 \\
		\end{bmatrix}
	\end{equation}
	
	The measurement matrix $H$ (referred to as $C$ in code) is defined as:
	
	\begin{equation}
		H = C = \begin{bmatrix}
			0 & 0 & 1 & 0 & 0 & 0 \\
			0 & 0 & 0 & 0 & 1 & 0 \\
			0 & 0 & 0 & 0 & 0 & 1
		\end{bmatrix}
	\end{equation}
	
	The implementation follows a standard \textbf{predict–correct cycle} (fig. \ref{fig:ekfprinciple}), executing in real-time within the simulation loop.
	
	\subsection{Prediction Step}
	
	First, the states are updated, and the estimate is stored as \texttt{state.estimate}.
		
	Following the state acquisition for the current timestep, the $F$ matrix is updated based on the current angle (\texttt{theta\_estimate}) and thrust (\texttt{control\_input}). This dependency characterizes the Extended Kalman Filter. The error covariance is then predicted:
	
	\begin{equation}
		P_k^- = A_k P_{k-1} A_k^T + W_k Q_{k-1} W_k^T 
	\end{equation}
	
	where $Q$ represents the confidence in the physics model.
	
	\subsection{Correction Step}
	The estimate is subsequently corrected using the latest noisy sensor data (\texttt{output.real}). The measurement residual—the discrepancy between sensor readings and predictions—is computed:
	
	The measurement residual, also known as the innovation, quantifies the discrepancy between the actual sensor measurements and the predicted output based on the a priori state estimate. It is computed as:
	\begin{equation}
		\tilde{\mathbf{y}}_k = \mathbf{z}_k - C \hat{\mathbf{x}}_k^-\label{eq:measurement_residual}
	\end{equation}
	where $\mathbf{z}_k$ represents the noisy sensor measurement vector at time step $k$, and $C \hat{\mathbf{x}}_k^-$ represents the predicted measurement derived from the current state estimate.
	
	The Kalman gain $K$ is calculated to determine the weighting between sensor data and physics predictions:
	\begin{align}
		S &= C P_k^- C^T + R \\
		K &= P_k^- C^T S^{-1}
	\end{align}
	
	Process noise covariance Q and measurement noise covariance R were defined as functions of noise amplitude. Normally, such data would not be accessible, but since an attempt to test EKF's capabilities is made, such decision is appropriate.
	
	Finally, the state and covariance matrices are updated to obtain the a posteriori estimates. The state estimate is corrected by adding the measurement residual, weighted by the Kalman gain $K$:
	\begin{equation}
		\hat{\mathbf{x}}_k = \hat{\mathbf{x}}_k^- + K_k \tilde{\mathbf{y}}_k\label{eq:ekf_state_update}
	\end{equation}
	Subsequently, the error covariance matrix $P$ is updated to reflect the reduced uncertainty following the incorporation of the measurement:
	\begin{equation}
		P_k = (I - K_k C) P_k^-\label{eq:ekf_covariance_update}
	\end{equation}
	
	
	\section{Running Mean Filter}
	
	In order to compare the performance of the EKF, the running mean filter was implemented. With the window size of 10, it simply averages the values from the last 10 time steps when processing sensor measurements. It then uses this data, to predict the change in states.
	
	The running mean filter implementation employs a hybrid estimation strategy. First, a sliding window average is applied to the noisy sensor measurements to attenuate high-frequency jitters. For a window size $N$, the smoothed measurement vector $\bar{\mathbf{z}}_t$ is computed as the arithmetic mean of the past $N$ observations:
	\begin{equation}
		\bar{\mathbf{z}}_t = \frac{1}{N} \sum_{k=t-N+1}^{t} \mathbf{z}_k\label{eq:moving_average}
	\end{equation}
	These smoothed measurements are directly substituted into the state vector for the observable variables ($y$, $\theta$, and $\dot{\theta}$), bypassing the dynamic model for these specific degrees of freedom.
	For the remaining unobserved states ($x$, $\dot{x}$, and $\dot{y}$), the filter utilizes the system dynamics (Eq. \ref{eq:x_dyn}-\ref{eq:y_dyn}) for propagation. Crucially, these dynamic updates rely on the smoothed orientation angle $\theta_t$ rather than the previous state estimate 3. The horizontal position is updated kinematically, while the velocity increments are derived from the thrust projections:
	\begin{align}
		\Delta x &= \dot{x}_{t-1} \Delta t \\
		\Delta \dot{x} &= -\frac{(u_1 + u_2)}{m}\sin(\theta_t) \Delta t \\
		\Delta \dot{y} &= \left( \frac{(u_1 + u_2)}{m}\cos(\theta_t) - g \right) \Delta t
	\end{align}
	Finally, these computed increments are applied to update the estimates for the horizontal position and linear velocities.
	
	\section{Results \& Visualization}
	
\begin{figure}[H]
	\centering
	\includegraphics[width=1\linewidth]{"Final State Estimation Basic"}
	\caption{The results of the simulation for the "basic" scenario.}
	\label{fig:final-state-estimation-basic}
\end{figure}

\begin{figure}[H]
	\centering
	\includegraphics[width=1\linewidth]{"Final State Estimation Horizontal"}
	\caption{The results of the simulation for the "horizontal" scenario.}
	\label{fig:final-state-estimation-horizontal}
\end{figure}

\begin{figure}[H]
	\centering
	\includegraphics[width=1\linewidth]{"Final State Estimation Roll"}
	\caption{The results of the simulation for the "roll" scenario.}
	\label{fig:final-state-estimation-roll}
\end{figure}

\begin{figure}[H]
	\centering
	\includegraphics[width=1\linewidth]{"Final State Estimation Fall"}
	\caption{The results of the simulation for the "fall" scenario.}
	\label{fig:final-state-estimation-fall}
\end{figure}

% --- ROBUSTNESS FIGURES ---

\begin{figure}[H]
	\centering
	\includegraphics[width=1\linewidth]{"Robustness Horizontal"}
	\caption{The results of the robustness test for the "horizontal" scenario.}
	\label{fig:robustness-horizontal}
\end{figure}

\begin{figure}[H]
	\centering
	\includegraphics[width=1\linewidth]{"Robustness Roll"}
	\caption{The results of the robustness test for the "roll" scenario.}
	\label{fig:robustness-roll}
\end{figure}

\begin{figure}[H]
	\centering
	\includegraphics[width=1\linewidth]{"Robustness Fall"}
	\caption{The results of the robustness test for the "fall" scenario.}
	\label{fig:robustness-fall}
\end{figure}

\begin{figure}[H]
	\centering
	\includegraphics[width=1\linewidth]{"Robustness Basic"}
	\caption{The results of the robustness test for the "basic" scenario.}
	\label{fig:robustness-basic}
\end{figure}
	
	Pablo
	
	The EKF successfully mitigates sensor noise while maintaining close tracking of the true trajectory. It outperforms Running Mean filter. However, it is important to acknowledge the fact that the filter is perfectly tuned in all the tested scenarios.
	
	Seed 47 was used for any random number generation in the report. All code can be accessed at https://github.com/Arseni10Lk/Planar-Quadrotor
	
	\section{Team member Contribution}
	
	I will add it later, just wanted to see if there is anything to correct before the final submission
	
	\newpage
	\appendix
	\section{Code}
	
	\subsection{Planar\_Quadrotor.m}
	
	\begin{lstlisting}[style=myMatlabStyle]
	clc;
	clear; 
	close all;
	
	rng(47);
	
	%% DEFINE VARIABLES
	m = 0.5;         % mass [kg] 
	r = 0.15;        % distance from center to rotors [m]
	I = 0.005;       % moment of inertia [kg*m^2]
	g = 9.81;        % gravity [m/s^2]
	dt = 0.01;       % time step [s] 
	theta = 0;       % angle [rads]
	u1 = 5;       % force [N]
	u2 = 5;       % force [N]
	
	% Structure definition
	rotor_data.m = m;
	rotor_data.r = r;
	rotor_data.I = I;
	rotor_data.g = g;
	rotor_data.dt = dt;
	rotor_data.theta = theta;
	rotor_data.u1 = u1;
	rotor_data.u2 = u2;
	
	t_max = 10;      % simulation duration [s]
	
	% A matrix - System dynamics
	A = [0  1  0  0   0   0;
	0  0  0  0   -cos(theta)*(u1+u2)/m   0;
	0  0  0  1   0   0;
	0  0  0  0   -sin(theta)*(u1+u2)/m   0;
	0  0  0  0   0   1;
	0  0  0  0   0   0];
	
	% It desscribes the states, so let's say it is rotor data 
	rotor_data.A = A;
	
	% C matrix - Measurements
	C = [0  0  1  0  0  0;
	0  0  0  0  1  0;
	0  0  0  0  0  1];
	
	rotor_data.C = C; % It says what we measure, so let's say it is rotor data 
	% (like what the sensors are)
	
	%% STEP 4: DEFINE TIME VECTOR
	time = 0:dt:t_max;  
	
	%% STEP 5: DEFINE CONTROL INPUTS
	% Create CU1 and CU2 (basic case)
	CU1 = u1 * 0.6 * (1 + 0.001*cos(2*time));  
	CU2 = u2 * 0.6 * (1 + 0.001*sin(2*time));
	
	% Create CU3 and CU4 (horizontal flight recovery)
	CU3 = zeros(size(time));
	CU4 = zeros(size(time));
	
	for t = 0:109 % roll up
	CU3(t + 1) = u1 * 0.81 * (1 + 0.001*cos(2 * 0.01 * t));
	CU4(t + 1) = u2 * 0.8 * (1 + 0.001*sin(2 * 0.01 * t));
	end
	for t = 110:219  % stop rotation
	CU3(t + 1) = u1 * 0.8 * (1 + 0.001*cos(2 * 0.01 * t));
	CU4(t + 1) = u2* 0.81 * (1 + 0.001*sin(2 * 0.01 * t));
	end
	for t = 220:length(time) % fly up
	CU3(t + 1) = u1 * 0.8 * (1 + 0.001*cos(2 * 0.01 * t));
	CU4(t + 1) = u2 * 0.8 * (1 + 0.001*sin(2 * 0.01 * t));
	end
	
	% Create CU5 and CU6 (360 roll)
	CU5 = zeros(size(time));
	CU6 = zeros(size(time));
	
	for t = 0:199 % iniiate roll
	CU5(t + 1) = u1 * 0.808 * (1 + 0.001*cos(2 * 0.01 * t));
	CU6(t + 1) = u2 * 0.8 * (1 + 0.001*sin(2 * 0.01 * t));
	end 
	for t = 200:299 % let it roll
	CU5(t + 1) = u1 * 0 * (1 + 0.001*cos(2 * 0.01 * t));
	CU6(t + 1) = u2 * 0 * (1 + 0.001*sin(2 * 0.01 * t));
	end 
	for t = 300:500 % stop rotation
	CU5(t + 1) = u1 * 0 * (1 + 0.001*cos(2 * 0.01 * t));
	CU6(t + 1) = u2 * 0.008 * (1 + 0.001*sin(2 * 0.01 * t));
	end
	for t = 501:length(time) % recover vertically
	CU5(t + 1) = u1 * (1 + 0.001*cos(2 * 0.01 * t));
	CU6(t + 1) = u2 * (1 + 0.001*sin(2 * 0.01 * t));
	end 
	
	% Create CU7 and CU8 (straight fall recovery)
	CU7 = u1 * 0.54 * (1 + 0.001*cos(2*time));
	CU8 = u2 * 0.54 * (1 + 0.001*sin(2*time));
	
	% Combine for sim
	control_input.basic = [CU1; CU2]';
	control_input.horizontal = [CU3; CU4]';
	control_input.roll = [CU5; CU6]';
	control_input.fall = [CU7; CU8]';
	
	
	%% STEP 6: DEFINE NOISE AMPLITUDE & robustness testing
	
	initial_state.basic = [0;0;1;0;0;0]; % basic case
	initial_state.horizontal = [0;3;10;0;-pi/2;0]; % horizontal flight recovery
	initial_state.roll = [0;0;50;5;0;0]; % roll 
	initial_state.fall = [0;-1;15;-3;-(pi/2-atan(3/1));0]; % straight fall recovery
	
	noise_data.state_noise_amp = 0.003;
	noise_data.output_noise_amp = 0.01;
	
	%% STEP 7: SIMULATION
	
	[states, output, error] = simulation_quadrotor(rotor_data, control_input.fall, noise_data, time, initial_state.fall);
	
	plot_quadrotor_enhanced(time, states, output, C, error);
	
	[rmse_mat, noise_mat, div_data, rmse_running] = robustness(rotor_data, control_input.fall, time, initial_state.fall, noise_data);
	
	plot_robustness_results(rmse_mat, noise_mat, div_data);
\end{lstlisting}

	\subsection{simulation\_quadrotor.m}
	\begin{lstlisting}[style=myMatlabStyle]
		function [state, output, errors] = simulation_quadrotor(rotor_data, control_input, noise_data, time, x0)
		
		% Three functions combined into one
		
		% getting all the quadrotor characteristics
		m = rotor_data.m; 
		r = rotor_data.r; 
		I = rotor_data.I; 
		g = rotor_data.g; 
		dt = rotor_data.dt;
		C = rotor_data.C;
		A = rotor_data.A;
		
		if nargin == 4
		x0 = zeros(1,6);
		end
		
		% Initialize output and states based on input parameters
		output.clean = zeros(length(time), size(C, 1));
		output.real = zeros(length(time), size(C, 1));
		output.filtered = zeros(length(time), size(C, 1));
		output.running = zeros(length(time), size(C, 1));%RUNNING
		
		state.clean = zeros(length(time), size(A, 1));
		state.real = zeros(length(time), size(A, 1));
		state.estimate = zeros(length(time), size(A, 1));
		state.running = zeros(length(time), size(A, 1));%RUNNING
		
		% Simulate the system dynamics over the specified time
		
		% Set initial state
		state.clean(1, :) = x0; 
		state.real(1, :) = x0; 
		state.estimate(1, :) = x0;
		state.running(1, :) = x0;%RUNNING
		
		output.clean(1, :) = C*state.clean(1, :)';
		output.real(1, :) = output.clean(1, :);
		output.filtered(1, :) = output.clean(1, :);
		output.running(1, :) = output.clean(1, :);%RUNNING
		
		% Filter data
		
		P = eye(6); % Initial Uncertainty
		% Q: Process Noise Covariance (Trust in Physics)
		% We use a small value to allow the model to drive the smoothness
		Q = eye(6) * (noise_data.state_noise_amp^2); 
		% R: Measurement Noise Covariance (Trust in Sensors)
		% We set this higher than actual noise to filter out the jitters
		R = eye(3) * (noise_data.output_noise_amp^2);
		
		% Running 
		window_size = 10; % You can adjust this window size
		
		for t = 2:length(time)
		
		%%% Perfect simulation
		
		% update theta
		theta_clean = state.clean(t - 1, 5);
		
		% Update states based on linear dynamics, this works for everything
		% except dx and dy
		delta_x_clean(1) = state.clean(t - 1, 2)*dt;
		delta_x_clean(3) = state.clean(t - 1, 4)*dt;
		delta_x_clean(5) = state.clean(t - 1, 6)*dt;
		delta_x_clean(6) = (r / I * control_input(t, 1) - r / I * control_input(t, 2)) * dt;
		
		% Now, non-linear part
		delta_x_clean(2) = (-sin(theta_clean)*(control_input(t, 1)+control_input(t, 2))/m) * dt;
		delta_x_clean(4) = (cos(theta_clean)*(control_input(t, 1)+control_input(t, 2))/m - g) * dt;
		
		
		% Lastly, updating states
		state.clean(t, :) = state.clean(t-1, :) + delta_x_clean(:)';
		output.clean(t, :) = (C * state.clean(t, :)')';
		
		%%% Real-world simulation
		
		% update theta
		theta_real = state.real(t - 1, 5);
		
		% Update states based on linear dynamics, this works for everything
		% except dx and dy
		delta_x_real(1) = state.real(t - 1, 2)*dt;
		delta_x_real(3) = state.real(t - 1, 4)*dt;
		delta_x_real(5) = state.real(t - 1, 6)*dt;
		delta_x_real(6) = (r / I * control_input(t, 1) - r / I * control_input(t, 2)) * dt;
		
		% Now, non-linear part
		delta_x_real(2) = (-sin(theta_real)*(control_input(t, 1)+control_input(t, 2))/m) * dt;
		delta_x_real(4) = (cos(theta_real)*(control_input(t, 1)+control_input(t, 2))/m - g) * dt;
		
		% getting all the noise characteristics
		state_noise = noise_data.state_noise_amp * randn(1, size(A, 1));
		output_noise = noise_data.output_noise_amp * randn(1, size(C, 1));
		
		state.real(t, :) = state.real(t - 1, :) + delta_x_real(:)' + state_noise;
		output.real(t, :) = (C*state.real(t, :)')' + output_noise;
		
		%%% Filter
		% Filter uses perfect physics and sensor measurements, but we do not pass
		% real state to it.
		
		% PREDICTION STEP
		
		% update theta
		theta_estimate = state.estimate(t - 1, 5);
		
		% Update states based on linear dynamics, this works for everything
		% except dx and dy
		delta_x_estimate(1) = state.estimate(t - 1, 2)*dt;
		delta_x_estimate(3) = state.estimate(t - 1, 4)*dt;
		delta_x_estimate(5) = state.estimate(t - 1, 6)*dt;
		delta_x_estimate(6) = (r / I * control_input(t, 1) - r / I * control_input(t, 2)) * dt;
		
		% Now, non-linear part
		delta_x_estimate(2) = (-sin(theta_estimate)*(control_input(t, 1)+control_input(t, 2))/m) * dt;
		delta_x_estimate(4) = (cos(theta_estimate)*(control_input(t, 1)+control_input(t, 2))/m - g) * dt;
		
		state.estimate(t, :) = state.estimate(t - 1, :) + delta_x_estimate(:)';
		
		% Predict covariance
		
		F = eye(6) + dt * [0 1 0 0 0 0;
		0 0 0 0 -cos(theta_estimate)*(control_input(t, 1)+control_input(t, 2))/m 0;
		0 0 0 1 0 0;
		0 0 0 0 -sin(theta_estimate)*(control_input(t, 1)+control_input(t, 2))/m 0;
		0 0 0 0 0 1;
		0 0 0 0 0 0];
		
		P_prediction = F * P * F' + Q;
		
		% CORRECTION STEP
		
		% 1. Calculate Measurement Residual 
		measurement_residual = output.real(t, :)' - C * state.estimate(t, :)';
		measurement_residual(2) = mod(measurement_residual(2) + pi, 2*pi) - pi;
		
		% 2. Calculate Kalman Gain
		S = C * P_prediction * C' + R;
		K = P_prediction * C' / S;
		
		% 3. Update State Estimate
		state.estimate(t, :) = state.estimate(t, :) + (K * measurement_residual)';
		output.filtered(t, :) = C * state.estimate(t, :)';
		
		% 4. Update Covariance
		P = (eye(6) - K * C) * P_prediction;
		
		
		% RUNNING 
		% Determine the start of the window
		window_start = max(1, t - window_size);
		
		% Average the noisy measurements ('real' outputs) over the window
		output.running(t, :) = mean(output.real(window_start:t, :), 1);
		
		% update theta
		theta_running = output.running(t, 2);
		
		state.running(t, 3) = output.running(t, 1); % Overwrite y (State 3)
		state.running(t, 5) = output.running(t, 2); % Overwrite theta (State 5)
		state.running(t, 6) = output.running(t, 3); % Overwrite theta_dot (State 6)
		
		% For the states, we apply the same averaging to the noisy running states
		% Update states based on linear dynamics, this works for everything
		% except dx and dy
		delta_x_running(1) = state.running(t-1, 2) * dt;
		
		% Now, non-linear part
		delta_x_running(2) = (-sin(theta_running)*(control_input(t, 1)+control_input(t, 2))/m) * dt;
		delta_x_running(4) = (cos(theta_running)*(control_input(t, 1)+control_input(t, 2))/m - g) * dt;
		
		state.running(t, [1 2 4]) = state.running(t - 1, [1 2 4]) + delta_x_running([1 2 4]);
		
		end
		
		%RUNNING
		errors.output_clean_VS_running_total = output.running - output.clean;
		errors.states_real_VS_running = state.real - state.running;
		
		errors.output_clean_VS_real_total = output.real - output.clean;
		errors.output_clean_VS_filtered_total = output.filtered - output.clean;
		errors.output_real_VS_filtered_total = output.filtered - output.real;
		
		errors.states_clean_VS_real_total = state.real - state.clean;
		errors.states_real_VS_estimate = state.real - state.estimate;
		errors.state_real_VS_output_real = output.real - state.real(:, [3, 5, 6]);
		errors.state_real_VS_output_filtered = output.filtered - state.real(:, [3, 5, 6]);
		
		% Calculate the Mean Squared Error for each column (state variable)
		num_states = size(errors.states_real_VS_estimate, 2);
		rmse_values = zeros(1, num_states);
		rmse_running = zeros(1, num_states);
		
		for i = 1:num_states
		% RMSE = sqrt(mean(error^2))
		rmse_values(i) = sqrt(mean(errors.states_real_VS_estimate(:, i).^2));
		%RUNNING
		rmse_running(i) = sqrt(mean(errors.states_real_VS_running(:, i).^2));
		end
		
		% Store the RMSE values in the errors structure
		% state variables are typically: [x, dx, y, dy, theta, dtheta]
		errors.rmse_states = rmse_values;
		%RUNNING
		errors.rmse_running = rmse_running;
		end
	\end{lstlisting}
	
	\subsection{robustness.m}
	\begin{lstlisting}[style=MyMatlabStyle]
		function [rmse_matrix, noise_matrix, divergence_data, rmse_matrix_running] = robustness(rotor_data, control_input, time, initial_state, noise_data_base)
		% ROBUSTNESS - Run robustness tests and return data for plotting
		% Returns: rmse_matrix (Kalman), noise_matrix, divergence_data, rmse_matrix_running (Running)
		
		fprintf('\n=== Running Robustness Analysis ===\n');
		
		% Define 4 noise cases (Cases 1-4)
		noise_cases = [
		0.0015, 0.01; % Case 1: Optimal
		0.003,  0.02; % Case 2: Regular
		0.015,  0.1;  % Case 3: High noise
		0.03,   0.2   % Case 4: Very high noise
		];
		
		num_cases = size(noise_cases, 1);
		rmse_matrix = zeros(num_cases, 6);
		rmse_matrix_running = zeros(num_cases, 6); % NEW: Store running filter RMSE
		noise_matrix = noise_cases;
		
		% Run simulations for Cases 1-4
		for case_num = 1:num_cases
		noise_data.state_noise_amp = noise_cases(case_num, 1);
		noise_data.output_noise_amp = noise_cases(case_num, 2);
		
		[~, ~, errors] = simulation_quadrotor(rotor_data, control_input, noise_data, time, initial_state);
		
		rmse_matrix(case_num, :) = errors.rmse_states;
		rmse_matrix_running(case_num, :) = errors.rmse_running; % NEW
		
		fprintf('Case %d RMSE (Kalman): ', case_num);
		fprintf('%.4f ', errors.rmse_states);
		fprintf('\n');
		end
		
		% Run divergence analysis
		divergence_data = find_divergence_individual_states(rotor_data, control_input, time, initial_state, noise_data_base);
		
		fprintf('\n=== Analysis Complete === \n');
		end
		
		%% ================= HELPER FUNCTION - TRACKS INDIVIDUAL STATE DIVERGENCE =================
		function div_data = find_divergence_individual_states(rotor_data, control_input, time, initial_state, noise_data_base)
		base_noise = [noise_data_base.state_noise_amp, noise_data_base.output_noise_amp]; % Base noise levels
		max_multiplier = 50;
		multiplier = 0.2; 
		
		div_data.multipliers = [];
		div_data.rmse_values = [];          % Kalman RMSE history
		div_data.rmse_values_running = [];  % NEW: Running RMSE history
		
		% State names
		state_names = {'x', 'dx', 'y', 'dy', 'theta', 'dtheta'};
		display_names = {'x', 'dx', 'y', 'dy', 'θ', 'dθ'};
		div_data.state_names = state_names;
		div_data.display_names = display_names;
		
		% Initialize divergence tracking for BOTH filters
		for i = 1:6
		% Kalman Tracking
		div_data.(['div_point_' state_names{i}]) = 0;
		div_data.(['actually_diverged_' state_names{i}]) = false;
		div_data.(['threshold_' state_names{i}]) = 0;
		
		% NEW: Running Filter Tracking
		div_data.(['div_point_running_' state_names{i}]) = 0;
		div_data.(['actually_diverged_running_' state_names{i}]) = false;
		end
		
		% Thresholds (Shared between filters)
		thresholds = [5.0, 1.0, 0.2, 0.2, 0.2, 0.1];  
		for i = 1:6
		div_data.(['threshold_' state_names{i}]) = thresholds(i);
		end
		
		fprintf('\n--- Starting Dual-Filter Divergence Analysis ---\n');
		
		iteration = 0;
		while multiplier <= max_multiplier
		iteration = iteration + 1;
		noise_data.state_noise_amp = base_noise(1) * multiplier;
		noise_data.output_noise_amp = base_noise(2) * multiplier;
		
		[~, ~, errors] = simulation_quadrotor(rotor_data, control_input, noise_data, time, initial_state);
		
		div_data.multipliers(end+1) = multiplier;
		div_data.rmse_values(end+1, :) = errors.rmse_states;
		div_data.rmse_values_running(end+1, :) = errors.rmse_running; % NEW
		
		% Check EACH STATE for divergence (Kalman & Running)
		for state_idx = 1:6
		threshold = thresholds(state_idx);
		s_name = state_names{state_idx};
		
		% 1. Check Kalman
		if errors.rmse_states(state_idx) > threshold
		if ~div_data.(['actually_diverged_' s_name])
		div_data.(['actually_diverged_' s_name]) = true;
		div_data.(['div_point_' s_name]) = multiplier;
		fprintf('  [Kalman]  %s diverged at %.1fx\n', display_names{state_idx}, multiplier);
		end
		end
		
		% 2. Check Running (NEW)
		if errors.rmse_running(state_idx) > threshold
		if ~div_data.(['actually_diverged_running_' s_name])
		div_data.(['actually_diverged_running_' s_name]) = true;
		div_data.(['div_point_running_' s_name]) = multiplier;
		fprintf('  [Running] %s diverged at %.1fx\n', display_names{state_idx}, multiplier);
		end
		end
		end
		
		% Progress
		if mod(iteration, 10) == 0
		fprintf('  Progress: %.1f/%.1f\n', multiplier, max_multiplier);
		end
		
		% Early exit: Only if BOTH filters have failed on ALL states
		all_diverged = true;
		for state_idx = 1:6
		s_name = state_names{state_idx};
		if ~div_data.(['actually_diverged_' s_name]) || ~div_data.(['actually_diverged_running_' s_name])
		all_diverged = false;
		break;
		end
		end
		
		if all_diverged
		fprintf('  All states in both filters diverged. Stopping.\n');
		break;
		end
		
		multiplier = multiplier + 0.2;
		end
		
		% Cleanup: Set stable states to max_tested
		max_tested = max(div_data.multipliers);
		div_data.max_multiplier_tested = max_tested;
		
		for state_idx = 1:6
		s_name = state_names{state_idx};
		if ~div_data.(['actually_diverged_' s_name])
		div_data.(['div_point_' s_name]) = max_tested;
		end
		if ~div_data.(['actually_diverged_running_' s_name])
		div_data.(['div_point_running_' s_name]) = max_tested;
		end
		end
		end
	\end{lstlisting}
	
\end{document}