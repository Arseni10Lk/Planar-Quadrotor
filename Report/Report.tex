\documentclass{turabian-researchpaper}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{amsmath, amssymb, amsfonts} % For math equations
\usepackage{csquotes, ellipsis}
\usepackage[scaled=0.85]{beramono}
\usepackage{xcolor}     % For code coloring
\usepackage{subcaption}
\usepackage[numbered,framed]{matlab-prettifier} 
\usepackage{listings}   % For code snippets
\lstset{
	inputencoding=utf8,
	extendedchars=true,
	literate={θ}{{$\theta$}}1
}
\usepackage{graphicx}   % For images
\usepackage{float}      % For figure placement

\usepackage{booktabs} % Required for TABLE
\usepackage{siunitx}  % Required for TABLE

\usepackage{pdflscape}

\usepackage[notes, backend=biber]{biblatex-chicago}
\addbibresource{works-cited.bib}

% Specify paper size
\usepackage[pass, letterpaper]{geometry}
\setcounter{tocdepth}{2}
% Code Listing Style Definition
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}
\lstdefinestyle{myMatlabStyle}{
	backgroundcolor=\color{backcolour},   % Your light beige background
	commentstyle=\color{codegreen},       % Your green comments
	keywordstyle=\color{blue},            % Standard blue keywords
	numberstyle=\tiny\color{codegray},    % Gray line numbers
	stringstyle=\color{codepurple},       % Purple strings
	basicstyle=\ttfamily\footnotesize,    % Monospace font
	breaklines=true,                 
	captionpos=b,                    
	keepspaces=true,                 
	numbers=left,                    
	numbersep=5pt,                  
	showspaces=false,                
	showstringspaces=false,
	showtabs=false,                  
	tabsize=2,
	language=Matlab                       % Enforce Matlab syntax highlighting
}

% --- Title Page Setup ---
\title{Planar Quadrotor}
\subtitle{Extended Kalman Filter Design}
\author{Arseni Lysak, Tsimafei Iliusenka, John Elvin Ndahiro, Pablo Calderon Mateo}

\course{Aeronautical Systems Integration}

\date{\today}

\begin{document}
	\maketitle
	
	\tableofcontents
	\newpage
	\section{Introduction}
	
	The aim of this project is to implement an Extended Kalman Filter (EKF) to estimate the movement of a 2D planar quadrotor (fig. \ref{fig:quadrotor_diagram}) utilizing noisy sensor measurements.
	 
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.8\textwidth]{Planar_Quadrotor.png}
		\caption{Diagram of the Planar Quadrotor System.}
		\label{fig:quadrotor_diagram}
	\end{figure}
	
	\section{System modeling}
	
	The movement of the quadrotor is governed by the following nonlinear equations of motion:
\begin{align}
	m\ddot{x} &= -(u_1 + u_2)\sin\theta \label{eq:x_dyn} \\
	m\ddot{y} &= (u_1 + u_2)\cos\theta - mg \label{eq:y_dyn} \\
	I\ddot{\theta} &= r(u_1 - u_2) \label{eq:theta_dyn}
\end{align}
	\noindent where:
	\begin{itemize}
		\item $m$: mass of the quadrotor
		\item $I$: moment of inertia
		\item $r$: distance from the center of mass to the rotors
		\item $g$: gravitational acceleration
		\item $u_1, u_2$: rotor thrust forces
	\end{itemize}
	
	This would imply that the system state is represented by a six-element vector $\mathbf{x}$, and the control input is represented by a two-element vector $\mathbf{u}$:
	\begin{equation}
		\mathbf{x} = 
		\begin{bmatrix}
			x \\ \dot{x} \\ y \\ \dot{y} \\ \theta \\ \dot{\theta}
		\end{bmatrix}, \quad
		\mathbf{u} = 
		\begin{bmatrix}
			u_1 \\ u_2
		\end{bmatrix}
	\end{equation}
	
	\section{Quadrotor Definition}
	
	The quadrotor system parameters were initialized with a mass $m = 0.5 \text{ kg}$, a rotor arm length $r = 0.15 \text{ m}$, and a moment of inertia $I = 0.005 \text{ kg} \cdot \text{m}^2$. The simulation utilizes a time step of $dt = 0.01 \text{ s}$ under standard gravitational acceleration $g = 9.81 \text{ m/s}^2$. Baseline rotor thrust forces are $u_1 = 5 \text{ N}$ and $u_2 = 5 \text{ N}$ (Appendix A, lines 8-15).
	
	Four scenarios for control inputs were chosen (Appendix A, lines 53-96): 
	
	\begin{enumerate}
		\item Flying up. For the simplest case, both rotors are set to 3 N ( fig. \ref{fig:trajectory-basic}).
		\item Recovery from horizontal flight (fig. \ref{fig:trajectory-horizontal}). To do this, the quadrotor system must rotate to have significant vertical thrust component. Three control stages are:
		\begin{enumerate}
			\item Initiate rotation. For 1.1 s create rotational moment by 0.05 N thrust difference between the rotors (4.05 N, 4.0 N).
			\item Stop the rotation. For the next 1.1 s we slow down the rotation with the opposing thrust moment (4.0 N, 4.05 N).
			\item Increase altitude. For the rest of the simulation time we pull up with same thrust of 4 N on both rotors.
		\end{enumerate}
		\item 360 degree roll (fig. \ref{fig:trajectory-roll}). This is the most complicated control-wise, due to the choice of long rotation. Altitude loss is significant. Four control stages are:
		\begin{enumerate}
			\item Initiate rotation. A small thrust difference is applied for the first 2 seconds (4.04 N, 4 N).
			\item Let it rotate. For a second, the system is set to 0 thrust to let it rotate freely.
			\item Stop the rotation. For another 2 seconds, we slow down the rotation, only using small thrust to avoid increasing falling speed (0 N, 0.04 N).
			\item Recover lost altitude. After 5 seconds of accurate controls, we set both rotors to their maximum (5 N) to avoid collision with the ground.
		\end{enumerate}
		\item Straight fall recovery (fig. \ref{fig:trajectory-fall}). Almost identical to the first case, however slightly higher thrust is assumed (3.2 N on both rotors).
	\end{enumerate}
	
	The small thrust variation of the rotor is inherently periodic and is recreated using simple trigonometric functions (cosine for rotor $u_1$, sine for rotor $u_2$).
	
	Moreover, a unique set of initial conditions was defined for each case (Appendix A, lines 99-102):
	\begin{enumerate}
		\item Zero velocity in both directions, system is 1 m above the ground, no rotation.
		\item The system is assumed to have a horizontal speed of 3 m/s at 10 m altitude, rotors' thrust is parallel to the ground.
		\item High vertical speed and altitude (5 m/s and 50 m respectively) are assumed. No initial rotational speed, system tilt or horizontal speed.
		\item Negative horizontal and vertical velocities (-1 m/s and -3 m/s respectively), altitude of 15 m. Quadrotor system is initially tilted down by around 18 degrees to align rotor thrust direction with total velocity vector.
	\end{enumerate}

    \section{Clean Simulation}
	
	Equations \ref{eq:x_dyn}-\ref{eq:theta_dyn} represent perfect conditions as they do not account for process noise. The state vector for this ideal trajectory is designated as \texttt{state.clean} in the code (Appendix B, line 24). This ensures the prediction adheres to the actual physical dynamics.
	
	The clean simulation utilizes first-order Euler integration to propagate the system state forward in time. At each time step $t$, the state increments are computed based on the previous state vector $\mathbf{x}_{t-1}$ and the current control inputs (Appendix B, lines 60-71). The positional and angular updates are derived linearly from the previous velocities:
	\begin{equation}
		\Delta x = \dot{x}_{t-1} \Delta t, \quad \Delta y = \dot{y}_{t-1} \Delta t, \quad \Delta \theta = \dot{\theta}_{t-1} \Delta t\label{eq:euler_kinematics}
	\end{equation}
	The changes in linear and angular velocities are calculated by discretizing the dynamic equations of motion (Eq.\ref{eq:x_dyn}-\ref{eq:theta_dyn}). These updates account for the non-linear coupling introduced by the quadrotor's orientation $\theta$:
	\begin{align}
		\Delta \dot{x} &= -\frac{(u_1 + u_2)}{m}\sin(\theta_{t-1}) \Delta t \label{eq:euler_dx} \\
		\Delta \dot{y} &= \left( \frac{(u_1 + u_2)}{m}\cos(\theta_{t-1}) - g \right) \Delta t \label{eq:euler_dy} \\
		\Delta \dot{\theta} &= \frac{r}{I}(u_1 - u_2) \Delta t \label{eq:euler_dtheta}
	\end{align}
	
	Finally, the state vector is updated by adding these increments to the previous state, $\mathbf{x}_t = \mathbf{x}_{t-1} + \Delta \mathbf{x}$, and the ideal sensor output is computed as $\mathbf{y}_t = C \mathbf{x}_t$ (Appendix B, lines 75, 76).
	
	\section{Real-World Trajectory}
	
	The real-world trajectory (\texttt{state.real}) differs from the perfect trajectory solely through the introduction of process and measurement noise. It is assumed that both process and measurement noise follow a \textbf{Gaussian} distribution, which is implemented in the simulation using the MATLAB function \texttt{randn} (Appendix B, lines 95-96). The stochastic properties are defined by their variances: the process noise variance is set to $0.003^2$, while the measurement noise variance is set to $0.01^2$ (Appendix B, lines 47-50).
	
	The governing equations \ref{eq:x_dyn}-\ref{eq:theta_dyn} remain unchanged, with noise injected during the state update step. The true state evolution is modeled by adding a stochastic process noise vector $\mathbf{w}$ to the deterministic dynamics:
	\begin{equation}
		\mathbf{x}_t = \mathbf{x}_{t-1} + \Delta \mathbf{x} + \mathbf{w}_{t-1}\label{eq:noisy_state_update}
	\end{equation}
	Subsequently, the simulated sensor measurements $\mathbf{z}_t$ are generated by applying the measurement matrix $C$ to the updated state, with the addition of measurement noise $\mathbf{v}_t$:
	\begin{equation}
		\mathbf{z}_t = C \mathbf{x}_t + \mathbf{v}_t\label{eq:noisy_measurement_update}
	\end{equation}
	
	\section{Extended Kalman Filter Design}
	
	The Linear Kalman filter addresses the general problem of trying to estimate the state of a discrete-time controlled process that is governed by a linear stochastic difference equation. A Kalman filter that linearizes about the current mean and covariance is referred to as an extended Kalman filter or EKF.
	
	The EKF is employed because the quadrotor system is nonlinear—motion is dependent on the sine and cosine of the angle $\theta$. The EKF linearizes the system at each time step using the current optimal estimate prior to applying standard Kalman update equations.
	
	The working principle of the filter is optimally weighting sensor measurements against the predicted values in accordance with the ideal mathematical model (fig. \ref{fig:ekfprinciple}).
		
	\begin{figure}
		\centering
		\includegraphics[width=1\linewidth]{ASI_EKFprinciple}
		\caption{A complete picture of the operation of the extended Kalman filter. Source: \cite{welch2002kalman}.}
		\label{fig:ekfprinciple}
	\end{figure}
	
	
	\subsection{Jacobian for Covariance Propagation}
	
	
	\noindent To estimate a process with non-linear difference and measurement relationships, the system is modeled using non-linear functions $f$ and $h$ \autocite{welch2002kalman}:
	\begin{align}
		\mathbf{x}_{k+1} &= f(\mathbf{x}_k, \mathbf{u}_k) + \mathbf{w}_k \label{eq:state_nonlinear} \\
		\mathbf{z}_k &= h(\mathbf{x}_k) + \mathbf{v}_k \label{eq:meas_nonlinear}
	\end{align}
	where:
	\begin{itemize}
		\item $\mathbf{x}_k$ is the state vector at time step $k$,
		\item $\mathbf{z}_k$ is the measurement vector,
		\item $\mathbf{u}_k$ is the control input vector,
		\item $\mathbf{w}_k$ and $\mathbf{v}_k$ are the process and measurement noise vectors respectively.
	\end{itemize}
	
	\noindent To linearize the estimate for covariance propagation, the Jacobian matrices $\mathbf{F}$ and $\mathbf{H}$ have to be computed:
	\begin{itemize}
		\item $\mathbf{F}_{k}$ is the Jacobian of the dynamics function $f$ with respect to the state $\mathbf{x}$, evaluated at the previous estimate $\hat{\mathbf{x}}_{k-1|k-1}:[\mathbf{F}_{k} = \left. \frac{\partial f}{\partial \mathbf{x}} \right|{\hat{\mathbf{x}}_{k-1|k-1}, \mathbf{u}_k}]$
		\item $\mathbf{H}_{k}$ is the Jacobian of the measurement function $h$ with respect to the state $\mathbf{x}$, evaluated at the predicted state $\hat{\mathbf{x}}_{k|k-1}:[\mathbf{H}_{k} = \left. \frac{\partial h}{\partial \mathbf{x}} \right|{\hat{\mathbf{x}}_{k|k-1}}]$
	\end{itemize}
		
	To update the error covariance, the state transition Jacobian $A$ is derived from the partial derivatives of the dynamics, which are defined by equations \ref{eq:x_dyn} - \ref{eq:theta_dyn}:
	\begin{align}
		\frac{\partial \ddot{x}}{\partial \theta} = -\frac{\cos\theta}{m}(u_1 + u_2) \label{eq:partial_x} \\
		\frac{\partial \ddot{y}}{\partial \theta} = -\frac{\sin\theta}{m}(u_1 + u_2) \label{eq:partial_y}
	\end{align}
	The resulting Jacobian $A$ is (Appendix A, lines 30-35):
	\begin{equation}
		A = \begin{bmatrix}
			0 & 1 & 0 & 0 & 0 & 0 \\
			0 & 0 & 0 & 0 & \frac{-\cos(\theta)(u_1+u_2)}{m} & 0 \\
			0 & 0 & 0 & 1 & 0 & 0 \\
			0 & 0 & 0 & 0 & \frac{-\sin(\theta)(u_1+u_2)}{m} & 0 \\
			0 & 0 & 0 & 0 & 0 & 1 \\
			0 & 0 & 0 & 0 & 0 & 0
		\end{bmatrix}
	\end{equation}
	The discrete-time state transition matrix $F$ used in the EKF is defined as $F = I + A \Delta t$, where $I$ represents the identity matrix and $A \Delta t$ represents the change over the time step.
	\begin{equation}
		F = \begin{bmatrix} 
			1 & \Delta t & 0 & 0 & 0 & 0 \\
			0 & 1 & 0 & 0 & \frac{-\cos(\theta)(u_1+u_2)}{m} \Delta t & 0 \\
			0 & 0 & 1 & \Delta t & 0 & 0 \\
			0 & 0 & 0 & 1 & \frac{-\sin(\theta)(u_1+u_2)}{m} \Delta t & 0 \\
			0 & 0 & 0 & 0 & 1 & \Delta t \\
			0 & 0 & 0 & 0 & 0 & 1 \\
		\end{bmatrix}
	\end{equation}
	The measurement matrix $H$ (referred to as $C$ in code) (Appendix A, lines 41-43) is defined as:
	\begin{equation}
		H = C = \begin{bmatrix}
			0 & 0 & 1 & 0 & 0 & 0 \\
			0 & 0 & 0 & 0 & 1 & 0 \\
			0 & 0 & 0 & 0 & 0 & 1
		\end{bmatrix}
	\end{equation}
	The implementation follows a standard \textbf{predict–correct cycle} (fig. \ref{fig:ekfprinciple}), executing in real-time within the simulation loop.
	
	\subsection{Prediction Step}
	
	First, the states are updated, and the estimate is stored as \texttt{state.estimate}.
		
	Following the state acquisition for the current timestep, the $F$ matrix is updated based on the current angle (\texttt{theta\_estimate}) and thrust (\texttt{control\_input}). This dependency characterizes the Extended Kalman Filter. The error covariance is then predicted:
	\begin{equation}
		P_k^- = A_k P_{k-1} A_k^T + W_k Q_{k-1} W_k^T 
	\end{equation}
	where $Q$ represents the confidence in the physics model.
	
	\subsection{Correction Step}
	The estimate is subsequently corrected using the latest noisy sensor data (\texttt{output.real}). The measurement residual—the discrepancy between sensor readings and predictions—is computed:
	
	The measurement residual, also known as the innovation, quantifies the discrepancy between the actual sensor measurements and the predicted output based on the a priori state estimate. It is computed as:
	\begin{equation}
		\tilde{\mathbf{y}}_k = \mathbf{z}_k - C \hat{\mathbf{x}}_k^-\label{eq:measurement_residual}
	\end{equation}
	where $\mathbf{z}_k$ represents the noisy sensor measurement vector at time step $k$, and $C \hat{\mathbf{x}}_k^-$ represents the predicted measurement derived from the current state estimate.
	
	The Kalman gain $K$ is calculated to determine the weighting between sensor data and physics predictions:
	\begin{align}
		S &= C P_k^- C^T + R \\
		K &= P_k^- C^T S^{-1} \label{eq:K}
	\end{align}
	The process noise covariance $Q$ and measurement noise covariance $R$ were defined as $I \times 0.003^2$ and $I \times 0.01^2$, respectively. This effectively means that the filter is "perfectly tuned."
	
	Finally, the state and covariance matrices are updated to obtain the posteriori estimates. The state estimate is corrected by adding the measurement residual, weighted by the Kalman gain $K$ (Appendix B, lines 145-146):
	\begin{equation}
		\hat{\mathbf{x}}_k = \hat{\mathbf{x}}_k^- + K_k \tilde{\mathbf{y}}_k\label{eq:ekf_state_update}
	\end{equation}
	Subsequently, the error covariance matrix $P$ is updated to reflect the reduced uncertainty following the incorporation of the measurement:
	\begin{equation}
		P_k = (I - K_k C) P_k^-\label{eq:ekf_covariance_update}
	\end{equation}
	

	\section{Running Mean Filter}
	
	In order to compare the performance of the EKF, the running mean filter was implemented. With a window size of 10 (Appendix B, line 53), it simply averages the values from the last 10 time steps when processing sensor measurements. It then uses this data to predict the change in states.
	
	The running mean filter implementation employs a hybrid estimation strategy. First, a sliding window average is applied to the noisy sensor measurements to attenuate high-frequency jitters. For a window size $N$, the smoothed measurement vector $\bar{\mathbf{z}}_t$ is computed as the arithmetic mean of the past $N$ observations (Appendix B, lines 162-164):
	\begin{equation}
		\bar{\mathbf{z}}_t = \frac{1}{N} \sum_{k=t-N+1}^{t} \mathbf{z}_k\label{eq:moving_average}
	\end{equation}
	These smoothed measurements are directly substituted into the state vector for the observable variables ($y$, $\theta$, and $\dot{\theta}$), bypassing the dynamic model for these specific degrees of freedom.
	For the remaining unobserved states ($x$, $\dot{x}$, and $\dot{y}$), the filter utilizes the system dynamics (Eq. \ref{eq:x_dyn}-\ref{eq:y_dyn}) for propagation. Crucially, these dynamic updates rely on the smoothed orientation angle $\theta_t$ rather than the previous state estimate. The horizontal position is updated kinematically, while the velocity increments are derived from the thrust projections:
	\begin{align}
		\Delta x &= \dot{x}_{t-1} \Delta t \\
		\Delta \dot{x} &= -\frac{(u_1 + u_2)}{m}\sin(\theta_t) \Delta t \\
		\Delta \dot{y} &= \left( \frac{(u_1 + u_2)}{m}\cos(\theta_t) - g \right) \Delta t
	\end{align}
	Finally, these computed increments are applied to update the estimates for the horizontal position and linear velocities (Appendix B, lines 169–175).
	
	\section{Results \& Visualization}

% ==================== 2D TRAJECTORIES ====================
\begin{figure}[H]
\centering
\includegraphics[width=1\linewidth]{trajectory-basic}
\caption{2D trajectory for the basic hover scenario, comparing EKF estimate against the real noisy path.}
\label{fig:trajectory-basic}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=1\linewidth]{trajectory-horizontal}
\caption{2D trajectory for the horizontal recovery scenario, showing EKF performance during lateral motion.}
\label{fig:trajectory-horizontal}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=1\linewidth]{trajectory-roll}
\caption{2D trajectory for the 360° roll scenario, illustrating EKF tracking during aggressive rotational motion.}
\label{fig:trajectory-roll}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=1\linewidth]{trajectory-fall}
\caption{2D trajectory for the straight fall recovery scenario, demonstrating EKF accuracy during descent.}
\label{fig:trajectory-fall}
\end{figure}

% ==================== INDIVIDUAL STATE PLOTS – BASIC ====================
\begin{figure}[p] % [p] to place this on its own page
	\centering
	
	% --- Row 1 ---
	\begin{subfigure}[b]{0.45\textwidth}
		\centering
		\includegraphics[width=\textwidth]{state_x-basic}
		\caption{Horizontal position ($x$)}
		\label{fig:state-x-basic}
	\end{subfigure}
	\hfill
	\begin{subfigure}[b]{0.45\textwidth}
		\centering
		\includegraphics[width=\textwidth]{state_dx_dt-basic}
		\caption{Horizontal velocity ($\dot{x}$)}
		\label{fig:state-dx-basic}
	\end{subfigure}
	
	\vspace{0.5cm} % Vertical spacing
	
	% --- Row 2 ---
	\begin{subfigure}[b]{0.45\textwidth}
		\centering
		\includegraphics[width=\textwidth]{state_y-basic}
		\caption{Vertical position ($y$)}
		\label{fig:state-y-basic}
	\end{subfigure}
	\hfill
	\begin{subfigure}[b]{0.45\textwidth}
		\centering
		\includegraphics[width=\textwidth]{state_dy_dt-basic}
		\caption{Vertical velocity ($\dot{y}$)}
		\label{fig:state-dy-basic}
	\end{subfigure}
	
	\vspace{0.5cm}
	
	% --- Row 3 ---
	\begin{subfigure}[b]{0.45\textwidth}
		\centering
		\includegraphics[width=\textwidth]{state_theta-basic}
		\caption{Pitch angle ($\theta$)}
		\label{fig:state-theta-basic}
	\end{subfigure}
	\hfill
	\begin{subfigure}[b]{0.45\textwidth}
		\centering
		\includegraphics[width=\textwidth]{state_dtheta_dt-basic}
		\caption{Pitch rate ($\dot{\theta}$)}
		\label{fig:state-dtheta-basic}
	\end{subfigure}
	
	% --- Main Caption with ALL original text included ---
	\caption{State variables over time for the basic scenario. 
		(a): Horizontal position ($x$): a small lateral displacement is caused by slight thrust asymmetry that induces a small rotation of the vehicle. 
		(b): Horizontal velocity ($\dot{x}$): oscillates around zero, indicating minor alternating horizontal accelerations. 
		(c): Vertical position ($y$): shows continuous ascent with no reversal in direction. 
		(d): Vertical velocity ($\dot{y}$): remains positive and increases smoothly, confirming upward motion. 
		(e): Pitch angle ($\theta$): positive and negative values represent alternating nose-up and nose-down orientations. 
		(f): Pitch rate ($\dot{\theta}$): zero crossings correspond to changes in rotational direction.}
	\label{fig:basic_scenario_grid}
\end{figure}

% ==================== INDIVIDUAL STATE PLOTS – HORIZONTAL ====================
\begin{figure}[p] % [p] places this on a dedicated page
	\centering
	
	% --- Row 1 ---
	\begin{subfigure}[b]{0.45\textwidth}
		\centering
		\includegraphics[width=\textwidth]{state_x-horizontal}
		\caption{Horizontal position ($x$)}
		\label{fig:state-x-horizontal}
	\end{subfigure}
	\hfill
	\begin{subfigure}[b]{0.45\textwidth}
		\centering
		\includegraphics[width=\textwidth]{state_dx_dt-horizontal}
		\caption{Horizontal velocity ($\dot{x}$)}
		\label{fig:state-dx-horizontal}
	\end{subfigure}
	
	\vspace{0.5cm} % Vertical spacing between rows
	
	% --- Row 2 ---
	\begin{subfigure}[b]{0.45\textwidth}
		\centering
		\includegraphics[width=\textwidth]{state_y-horizontal}
		\caption{Vertical position ($y$)}
		\label{fig:state-y-horizontal}
	\end{subfigure}
	\hfill
	\begin{subfigure}[b]{0.45\textwidth}
		\centering
		\includegraphics[width=\textwidth]{state_dy_dt-horizontal}
		\caption{Vertical velocity ($\dot{y}$)}
		\label{fig:state-dy-horizontal}
	\end{subfigure}
	
	\vspace{0.5cm}
	
	% --- Row 3 ---
	\begin{subfigure}[b]{0.45\textwidth}
		\centering
		\includegraphics[width=\textwidth]{state_theta-horizontal}
		\caption{Pitch angle ($\theta$)}
		\label{fig:state-theta-horizontal}
	\end{subfigure}
	\hfill
	\begin{subfigure}[b]{0.45\textwidth}
		\centering
		\includegraphics[width=\textwidth]{state_dtheta_dt-horizontal}
		\caption{Pitch rate ($\dot{\theta}$)}
		\label{fig:state-dtheta-horizontal}
	\end{subfigure}
	
	% --- Main Caption with ALL original text included ---
	\caption{State variables over time for the horizontal and horizontal recovery scenarios. 
		(a) Horizontal position ($x$): shows sustained lateral movement in a single direction. 
		(b) Horizontal velocity ($\dot{x}$): variations in slope indicate acceleration and deceleration phases. 
		(c) Vertical position ($y$): decreases initially then increases. 
		(d) Vertical velocity ($\dot{y}$): negative values indicate descent and the zero crossing marks direction reversal. 
		(e) Pitch angle ($\theta$): shows rapid attitude change followed by gradual stabilization. 
		(f) Pitch rate ($\dot{\theta}$): is characterized by high initial rotation rates that later reduce in magnitude.}
	\label{fig:horizontal_scenario_grid}
\end{figure}

% ==================== INDIVIDUAL STATE PLOTS – ROLL ====================
\begin{figure}[p] % [p] places this on a dedicated page to ensure all 6 fit
	\centering
	
	% --- Row 1 ---
	\begin{subfigure}[b]{0.45\textwidth}
		\centering
		\includegraphics[width=\textwidth]{state_x-roll}
		\caption{Horizontal position ($x$)}
		\label{fig:state-x-roll}
	\end{subfigure}
	\hfill
	\begin{subfigure}[b]{0.45\textwidth}
		\centering
		\includegraphics[width=\textwidth]{state_dx_dt-roll}
		\caption{Horizontal velocity ($\dot{x}$)}
		\label{fig:state-dx-roll}
	\end{subfigure}
	
	\vspace{0.5cm} % Vertical spacing between rows
	
	% --- Row 2 ---
	\begin{subfigure}[b]{0.45\textwidth}
		\centering
		\includegraphics[width=\textwidth]{state_y-roll}
		\caption{Vertical position ($y$)}
		\label{fig:state-y-roll}
	\end{subfigure}
	\hfill
	\begin{subfigure}[b]{0.45\textwidth}
		\centering
		\includegraphics[width=\textwidth]{state_dy_dt-roll}
		\caption{Vertical velocity ($\dot{y}$)}
		\label{fig:state-dy-roll}
	\end{subfigure}
	
	\vspace{0.5cm}
	
	% --- Row 3 ---
	\begin{subfigure}[b]{0.45\textwidth}
		\centering
		\includegraphics[width=\textwidth]{state_theta-roll}
		\caption{Pitch angle ($\theta$)}
		\label{fig:state-theta-roll}
	\end{subfigure}
	\hfill
	\begin{subfigure}[b]{0.45\textwidth}
		\centering
		\includegraphics[width=\textwidth]{state_dtheta_dt-roll}
		\caption{Pitch rate ($\dot{\theta}$)}
		\label{fig:state-dtheta-roll}
	\end{subfigure}
	
	% --- Main Caption with ALL original text included ---
	\caption{State variables over time for the roll scenario. 
		(a) Horizontal position ($x$): decreases continuously, indicating motion opposite to the reference direction. 
		(b) Horizontal velocity ($\dot{x}$): remains negative throughout, confirming persistent backward motion. 
		(c) Vertical position ($y$): shows alternating ascent and descent with clear extrema. 
		(d) Vertical velocity ($\dot{y}$): exhibits multiple zero crossings, indicating repeated reversals in vertical motion. 
		(e) Pitch angle ($\theta$): exceeds $360^\circ$, confirming completion of a full rotational maneuver. 
		(f) Pitch rate ($\dot{\theta}$): shows large positive values indicating rapid rotation and negative values marking deceleration.}
	\label{fig:roll_scenario_grid}
\end{figure}

% ==================== INDIVIDUAL STATE PLOTS – FALL ====================
\begin{figure}[p] % [p] suggests placing this on its own dedicated page
	\centering
	
	% --- Row 1 ---
	\begin{subfigure}[b]{0.45\textwidth}
		\centering
		\includegraphics[width=\textwidth]{state_x-fall}
		\caption{Horizontal position ($x$)}
		\label{fig:state-x-fall}
	\end{subfigure}
	\hfill
	\begin{subfigure}[b]{0.45\textwidth}
		\centering
		\includegraphics[width=\textwidth]{state_dx_dt-fall}
		\caption{Horizontal velocity ($\dot{x}$)}
		\label{fig:state-dx-fall}
	\end{subfigure}
	
	\vspace{0.5cm} % Adjust vertical spacing between rows here
	
	% --- Row 2 ---
	\begin{subfigure}[b]{0.45\textwidth}
		\centering
		\includegraphics[width=\textwidth]{state_y-fall}
		\caption{Vertical position ($y$)}
		\label{fig:state-y-fall}
	\end{subfigure}
	\hfill
	\begin{subfigure}[b]{0.45\textwidth}
		\centering
		\includegraphics[width=\textwidth]{state_dy_dt-fall}
		\caption{Vertical velocity ($\dot{y}$)}
		\label{fig:state-dy-fall}
	\end{subfigure}
	
	\vspace{0.5cm}
	
	% --- Row 3 ---
	\begin{subfigure}[b]{0.45\textwidth}
		\centering
		\includegraphics[width=\textwidth]{state_theta-fall}
		\caption{Pitch angle ($\theta$)}
		\label{fig:state-theta-fall}
	\end{subfigure}
	\hfill
	\begin{subfigure}[b]{0.45\textwidth}
		\centering
		\includegraphics[width=\textwidth]{state_dtheta_dt-fall}
		\caption{Pitch rate ($\dot{\theta}$)}
		\label{fig:state-dtheta-fall}
	\end{subfigure}
	
	% --- Main Caption (CMOS Requirement) ---
	\caption{State variables over time for the fall scenario. 
		(a) Horizontal position ($x$): shows continuous forward motion during descent. 
		(b) Horizontal velocity ($\dot{x}$): increases almost linearly, indicating constant horizontal acceleration. 
		(c) Vertical position ($y$): decreases to a minimum before slight recovery, marking the lowest altitude reached. 
		(d) Vertical velocity ($\dot{y}$): is negative during free fall and approaching zero as recovery thrust is applied. 
		(e) Pitch angle ($\theta$): shows progressive nose-down rotation caused by loss of vertical stability. 
		(f) Pitch rate ($\dot{\theta}$): oscillates with sign changes that reflect alternating rotational actions due to the process noise.}
	\label{fig:fall_scenario_grid}
\end{figure}

% ==================== ESTIMATION ERROR PLOTS ====================
\begin{figure}[H]
\centering
\includegraphics[width=0.8\linewidth]{estimation_errors-basic}
\caption{Absolute estimation errors for all states over time (basic scenario), comparing EKF and running mean filters. While some states show varying benefit of EKF over running mean ($x$, $\dot{x}$, $\dot{y}$), and others show significant error spikes of running mean ($\theta$, $\dot{\theta}$), $y$ in particular displays constant growth of running mean error, while its EKF error stays almost constant.}
\label{fig:error-basic}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=0.8\linewidth]{estimation_errors-horizontal}
\caption{Absolute estimation errors for all states over time (horizontal recovery scenario). With a more control-heavy case, running mean errors show significant increase, unbound in cases of $x$, $y$ and $\theta$.}
\label{fig:error-horizontal}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=0.8\linewidth]{estimation_errors-roll}
\caption{Absolute estimation errors for all states over time (roll scenario). This challenging simulation shows unreliability of running mean for complicated system movement.}
\label{fig:error-roll}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=0.8\linewidth]{estimation_errors-fall}
\caption{Absolute estimation errors for all states over time (fall recovery scenario). Not explicitly rotating system, just like the basic scenario, shows varying accuracy of running mean. Although $y$ error is now bounded, error spikes of $\theta$ and $\dot{\theta}$ cannot be ignored.}
\label{fig:error-fall}
\end{figure}

% ==================== NOISE LEVELS PLOTS ====================
\begin{figure}[H]
\centering
\includegraphics[width=0.7\linewidth]{noise_levels-basic}
\caption{Process and measurement variance for robustness analysis. These values don't vary between the scenarios.}
\label{fig:noise-levels-basic}
\end{figure}

% ==================== EKF RMSE ACROSS NOISE CONDITIONS ====================
\begin{figure}[H]
\centering
\includegraphics[width=0.7\linewidth]{robustness_rmse-basic}
\caption{EKF RMSE across four noise levels for each state (basic scenario). For the most part, RMSE increases along with variance, however $x$ and $\dot{x}$ are slightly different due to their progressing Euler integration error. Same trend can be expected in the other cases.}
\label{fig:rmse-ekf-basic}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=0.7\linewidth]{robustness_rmse-horizontal}
\caption{EKF RMSE across four noise levels for each state (horizontal recovery scenario). As expected, $x$ is still different from the rest, for the same reasons as described in Figure \ref{fig:rmse-ekf-basic} description. Maximum RMSE values have grown compared to the basic case because of the increased movement complexity.}
\label{fig:rmse-ekf-horizontal}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=0.7\linewidth]{robustness_rmse-roll}
\caption{EKF RMSE across four noise levels for each state (roll scenario). Once again, $x$ and its derivative display different RMSE progression when compared to the rest. This time, high variance leads to the highest RMSE values, even overtaking the very high variance.}
\label{fig:rmse-ekf-roll}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=0.7\linewidth]{robustness_rmse-fall}
\caption{EKF RMSE across four noise levels for each state (fall recovery scenario). For a simple motion, same RMSE trend is seen as for the basic case (fig. \ref{fig:rmse-ekf-basic}), with similar RMSE values as well.}
\label{fig:rmse-ekf-fall}
\end{figure}

% ==================== RMSE GROWTH – LOG SCALE ====================
\begin{figure}[H]
\centering
\includegraphics[width=0.7\linewidth]{rmse_growth_log-basic}
\caption{RMSE growth for $x$ and $\dot{x}$ under increasing noise (log scale, basic scenario). As discussed previously, $x$ and $\dot{x}$ are system parameters that have the biggest errors. In the simplest case, running mean is not so far from the EKF in terms of robustness.}
\label{fig:rmse-growth-log-basic}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=0.7\linewidth]{rmse_growth_log-horizontal}
\caption{RMSE growth for $x$ and $\dot{x}$ under increasing noise (log scale, horizontal recovery scenario). Complex dynamic maneuvers are difficult for the running mean filter to track. Divergence of running mean happens significantly earlier compared to EKF.}
\label{fig:rmse-growth-log-horizontal}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=0.7\linewidth]{rmse_growth_log-roll}
\caption{RMSE growth for $x$ and $\dot{x}$ under increasing noise (log scale, roll scenario). In this control-heavy scenario, the running mean diverges early once again. Interesting difference is early divergence of $\dot{x}$.}
\label{fig:rmse-growth-log-roll}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=0.7\linewidth]{rmse_growth_log-fall}
\caption{RMSE growth for $x$ and $\dot{x}$ under increasing noise (log scale, fall recovery scenario). As stated before, in simple simulations without rotation running mean is actually comparable in efficiency with the EKF.}
\label{fig:rmse-growth-log-fall}
\end{figure}

% ==================== RMSE GROWTH – LINEAR SCALE ====================
\begin{figure}[H]
\centering
\includegraphics[width=0.75\linewidth]{rmse_growth_linear-basic}
\caption{RMSE growth for $y$, $\dot{y}$, $\theta$, and $\dot{\theta}$ under increasing noise (linear scale, basic scenario). Unlike the log scale of $x$ and $\dot{x}$, other system parameters RMSE growth can be displayed normally. Measured parameters of the system have significantly higher variance multiplier required for divergence.}
\label{fig:rmse-growth-linear-basic}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=0.75\linewidth]{rmse_growth_linear-horizontal}
\caption{RMSE growth for $y$, $\dot{y}$, $\theta$, and $\dot{\theta}$ under increasing noise (linear scale, horizontal recovery scenario). The only visible difference present is some slight running mean divergence multiplier (which shows how stable EKF is with different flight cases).}
\label{fig:rmse-growth-linear-horizontal}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=0.75\linewidth]{rmse_growth_linear-roll}
\caption{RMSE growth for $y$, $\dot{y}$, $\theta$, and $\dot{\theta}$ under increasing noise (linear scale, roll scenario). Another case, another running mean multiplier change, EKF is stable as in the two previous examples (figs. \ref{fig:rmse-growth-linear-basic}, \ref{fig:rmse-growth-linear-horizontal})}
\label{fig:rmse-growth-linear-roll}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=0.75\linewidth]{rmse_growth_linear-fall}
\caption{RMSE growth for $y$, $\dot{y}$, $\theta$, and $\dot{\theta}$ under increasing noise (linear scale, fall recovery scenario). The last case definitely proves the point of EKF divergence multiplier stability for different flight conditions of the quadrotor system.}
\label{fig:rmse-growth-linear-fall}
\end{figure}

	\begin{table}[H]
    \centering
    \caption{RMSE Values for State Variables for the horizontal simulation scenario (figs. \ref{fig:trajectory-horizontal},\ref{fig:horizontal_scenario_grid})}
    \label{tab:rmse_results}
    \begin{tabular}{lccc}
        \toprule
        \textbf{Variable} & \textbf{Kalman RMSE} & \textbf{Running Mean RMSE} & \textbf{Unfiltered RMSE} \\
        \midrule
        $x$               & 0.0417 & 0.6632 & - \\
        $\dot{x}$         & 0.0222 & 0.1866 & - \\
        $y$               & 0.0084 & 0.5453 & 0.0098 \\
        $\dot{y}$         & 0.0659 & 0.1902 & - \\        $\theta$          & 0.0084 & 0.0100 & 0.0101 \\
        $\dot{\theta}$    & 0.0083 & 0.0095 & 0.0104 \\
        \bottomrule
    \end{tabular}
\end{table}

	\subsection{Analysis of Estimation Performance}
	
	The quantitative results presented in Table \ref{tab:rmse_results} demonstrate that the Extended Kalman Filter (EKF) significantly outperforms the running mean filter across all state variables. This performance gap is most pronounced in the unobserved states—specifically horizontal position ($x$), horizontal velocity ($\dot{x}$), and vertical velocity ($\dot{y}$). While the running mean filter achieves a Root Mean Square Error (RMSE) of 0.6632 m for the horizontal position, the EKF maintains an accuracy of 0.0417 m (fig. \ref{fig:error-horizontal}). This disparity arises because the running mean filter relies on a simplified kinematic propagation for unobserved states (Appendix B, lines 162–173), which lacks the corrective feedback mechanism found in the EKF’s state update equation (Eq. \ref{eq:ekf_state_update}).The EKF’s superior handling of nonlinearities is evident in the "Roll" scenario (Figure \ref{fig:trajectory-roll}). As the quadrotor undergoes a complete 360-degree rotation, the system dynamics become highly nonlinear due to the trigonometric coupling of the thrust vectors (Eq. \ref{eq:x_dyn}-\ref{eq:y_dyn}). The running mean filter, which simply smooths the sensor output (Eq. \ref{eq:moving_average}) and integrates the result, fails to account for the rapid changes in orientation, leading to the unbounded error growth observed in Figure \ref{fig:error-roll}. Conversely, the EKF updates its Jacobian matrix $F$ at every time step using the current state estimate (Appendix B, lines 108, 125-130), allowing it to accurately track the trajectory even during aggressive maneuvers.
	
	\subsection{Robustness Testing Methodology}
	To evaluate the stability of the estimators under adverse conditions, a robustness analysis was conducted by systematically increasing the process and measurement noise levels. The testing procedure, implemented in robustness.m (Appendix C), applies a scalar multiplier to the baseline noise variances defined in the simulation (Appendix A, lines 112-113). The multiplier ranges from $0.2\times$ to $50\times$ the nominal values, effectively simulating sensor degradation and increasing environmental turbulence (Appendix C, lines 44-45).
	
	To quantify the limits of stability, specific divergence thresholds were defined for each state variable. A filter is considered to have "diverged" when its Root Mean Square Error (RMSE) exceeds these pre-defined safety limits: $5.0 \text{ m}$ for horizontal position ($x$), $1.0 \text{ m/s}$ for horizontal velocity ($\dot{x}$), and $0.2$ for both vertical position ($y$) and vertical velocity ($\dot{y}$) (Appendix C, line 70). Tighter constraints were applied to the rotational states, with thresholds of $0.2 \text{ rad}$ for pitch angle ($\theta$) and $0.1 \text{ rad/s}$ for pitch rate ($\dot{\theta}$), reflecting the critical importance of attitude estimation for stable flight (Appendix C, line 70). The robustness loop iterates through increasing noise multipliers until these specific thresholds are breached, recording the multiplier value at which failure occurs (Appendix C, line 85).
	
	\subsection{Robustness Analysis Conclusions}
	The response to increasing noise reveals a fundamental difference in filter architecture. As illustrated in the logarithmic growth plots (Figures \ref{fig:rmse-growth-log-basic}- \ref{fig:rmse-growth-log-fall}), the error in the EKF estimates grows with the noise magnitude, maintaining stability even at high variance levels (figs. \ref{fig:rmse-ekf-basic} - \ref{fig:rmse-ekf-fall}). In contrast, the running mean filter exhibits early divergence, particularly for the horizontal states ($x$ and $\dot{x}$). In the "Horizontal Recovery" scenario, the running mean’s estimation of $\dot{x}$ diverges significantly earlier than the EKF (Figure \ref{fig:rmse-growth-log-horizontal}). This is attributed to the integration of noisy orientation data without covariance tracking; the EKF mitigates this by weighing the theoretical model against the noisy measurements via the Kalman Gain $K$ (Eq. \ref{eq:measurement_residual}-\ref{eq:K}, Appendix B, line 142). The linear scale plots (Figures \ref{fig:rmse-growth-linear-basic}-\ref{fig:rmse-growth-linear-fall}) further confirm that while observed states ($y, \theta$) are relatively resilient in both filters due to direct sensor updates, the EKF provides a necessary layer of filtering that prevents high-frequency noise from corrupting the velocity estimates. Ultimately, the EKF proves to be the robust solution required for the nonlinear dynamics of the planar quadrotor. However, it is important to acknowledge that the filter was perfectly tuned in all the tested scenarios, implying that tuning is a key to robust performance.
	
	Seed 47 was used for any random number generation in the report. All code can be accessed at https://github.com/Arseni10Lk/Planar-Quadrotor
	
	\section{Team Member Contributions}
	
	\vspace{\baselineskip}
	\subsection{Formal Roles}
	Arseni Lysak - Lead \\
	Tsimafei Iliusenka - System Modeling \& Simulation Specialist \\
	John Elvin Ndahiro - Presentation \& Demonstration Specialist\\
	Pablo Calderon Mateo - Technical Engineer\\
	
	
	\subsection{Actual Tasks}
	
	\noindent Arseni Lysak: 
	\begin{itemize}
		\item Task assignment, deadline setting and organization.
		\item Technical assistance with GitHub, Git, MATLAB, and LaTeX.
		\item Work review and quality assurance.
		\item Implementation of Real and Clean simulation code with error calculation (but not RMSE).
		\item Finalization of the EKF and Running Mean filter implementations.
		\item Adjustment and correction of critical mistakes in the plotting functions for simulation and robustness testing.
		\item Report writing and editing.
	\end{itemize}
	Tsimafei Iliusenka:
	\begin{itemize}
		\item Analytical solution to find Jacobian.
		\item Initial Extended Kalman filter design in code.
		\item Control inputs 2-4 design.
		\item Presentation template research.
		\item Presentation Design verification.
		\item \textbf{Always} delivered before the deadline.
	\end{itemize}
	John Elvin Ndahiro: 
	\begin{itemize}
		\item Initial ReadMe file writing.
		\item Research to define typical physical parameters of a drone.
		\item Control input 1 design.
		\item Initial plotting functions for the simulation.
		\item Final plotting functions for Simulation and Robustness Testing.
	\end{itemize}
	Pablo Calderon Mateo:
	\begin{itemize}
		\item System definition in code.
		\item RMSE computation.
		\item Initial Robustness Testing System design.
		\item Base Noise Variance selection.
		\item Design of a running mean filter template.
		\item Presentation Design.
	\end{itemize}
	
	\printbibliography
	\newpage
	\appendix
	\section{Planar\_Quadrotor.m}
	
	\begin{lstlisting}[style=myMatlabStyle]
clc;
clear; 
close all;

rng(47);

%% DEFINE VARIABLES
m = 0.5;         % mass [kg] 
r = 0.15;        % distance from center to rotors [m]
I = 0.005;       % moment of inertia [kg*m^2]
g = 9.81;        % gravity [m/s^2]
dt = 0.01;       % time step [s] 
theta = 0;       % angle [rads]
u1 = 5;       % force [N]
u2 = 5;       % force [N]

% Structure definition
rotor_data.m = m;
rotor_data.r = r;
rotor_data.I = I;
rotor_data.g = g;
rotor_data.dt = dt;
rotor_data.theta = theta;
rotor_data.u1 = u1;
rotor_data.u2 = u2;

t_max = 10;      % simulation duration [s]

% A matrix - System dynamics
A = [0  1  0  0   0   0;
0  0  0  0   -cos(theta)*(u1+u2)/m   0;
0  0  0  1   0   0;
0  0  0  0   -sin(theta)*(u1+u2)/m   0;
0  0  0  0   0   1;
0  0  0  0   0   0];

% It describes the states, so let's say it is rotor data 
rotor_data.A = A;

% C matrix - Measurements
C = [0  0  1  0  0  0;
0  0  0  0  1  0;
0  0  0  0  0  1];

rotor_data.C = C; % It says what we measure, so let's say it is rotor data 
% (like what the sensors are)

%% STEP 4: DEFINE TIME VECTOR
time = 0:dt:t_max;  

%% STEP 5: DEFINE CONTROL INPUTS
% Create CU1 and CU2 (basic case)
CU1 = u1 * 0.6 * (1 + 0.001*cos(2*time));  
CU2 = u2 * 0.6 * (1 + 0.001*sin(2*time));

% Create CU3 and CU4 (horizontal flight recovery)
CU3 = zeros(size(time));
CU4 = zeros(size(time));

for t = 0:109 % roll up
CU3(t + 1) = u1 * 0.81 * (1 + 0.001*cos(2 * 0.01 * t));
CU4(t + 1) = u2 * 0.8 * (1 + 0.001*sin(2 * 0.01 * t));
end
for t = 110:219  % stop rotation
CU3(t + 1) = u1 * 0.8 * (1 + 0.001*cos(2 * 0.01 * t));
CU4(t + 1) = u2* 0.81 * (1 + 0.001*sin(2 * 0.01 * t));
end
for t = 220:length(time) % fly up
CU3(t + 1) = u1 * 0.8 * (1 + 0.001*cos(2 * 0.01 * t));
CU4(t + 1) = u2 * 0.8 * (1 + 0.001*sin(2 * 0.01 * t));
end

% Create CU5 and CU6 (360 roll)
CU5 = zeros(size(time));
CU6 = zeros(size(time));

for t = 0:199 % initiate roll
CU5(t + 1) = u1 * 0.808 * (1 + 0.001*cos(2 * 0.01 * t));
CU6(t + 1) = u2 * 0.8 * (1 + 0.001*sin(2 * 0.01 * t));
end 
for t = 200:299 % let it roll
CU5(t + 1) = u1 * 0 * (1 + 0.001*cos(2 * 0.01 * t));
CU6(t + 1) = u2 * 0 * (1 + 0.001*sin(2 * 0.01 * t));
end 
for t = 300:500 % stop rotation
CU5(t + 1) = u1 * 0 * (1 + 0.001*cos(2 * 0.01 * t));
CU6(t + 1) = u2 * 0.008 * (1 + 0.001*sin(2 * 0.01 * t));
end
for t = 501:length(time) % recover vertically
CU5(t + 1) = u1 * (1 + 0.001*cos(2 * 0.01 * t));
CU6(t + 1) = u2 * (1 + 0.001*sin(2 * 0.01 * t));
end 

% Create CU7 and CU8 (straight fall recovery)
CU7 = u1 * 0.54 * (1 + 0.001*cos(2*time));
CU8 = u2 * 0.54 * (1 + 0.001*sin(2*time));

% Combine for sim
control_input.basic = [CU1; CU2]';
control_input.horizontal = [CU3; CU4]';
control_input.roll = [CU5; CU6]';
control_input.fall = [CU7; CU8]';


%% STEP 6: DEFINE NOISE AMPLITUDE & robustness testing

initial_state.basic = [0;0;1;0;0;0]; % basic case
initial_state.horizontal = [0;3;10;0;-pi/2;0]; % horizontal flight recovery
initial_state.roll = [0;0;50;5;0;0]; % roll 
initial_state.fall = [0;-1;15;-3;-(pi/2-atan(3/1));0]; % straight fall recovery

noise_data.state_noise_amp = 0.003;
noise_data.output_noise_amp = 0.01;

%% STEP 7: SIMULATION

% Define the test case name here (e.g., 'fall', 'basic', 'roll', 'horizontal')
current_case = 'roll'; 

[states, output, error] = simulation_quadrotor(rotor_data, control_input.(current_case), noise_data, time, initial_state.(current_case));

% Run Robustness
[rmse_mat, noise_mat, div_data, rmse_running] = robustness(rotor_data, control_input.(current_case), time, initial_state.(current_case), noise_data);

% New functions with saving logic:
% Pass 'current_case' to save files with that specific name
% plot_robustness_separate_windows(rmse_mat, noise_mat, div_data, current_case);

plot_quadrotor_separate_windows(time, states, output, C, error, current_case);
\end{lstlisting}

	\section{simulation\_quadrotor.m}
	\begin{lstlisting}[style=myMatlabStyle]
function [state, output, errors] = simulation_quadrotor(rotor_data, control_input, noise_data, time, x0)

% Three functions combined into one

% getting all the quadrotor characteristics
m = rotor_data.m; 
r = rotor_data.r; 
I = rotor_data.I; 
g = rotor_data.g; 
dt = rotor_data.dt;
C = rotor_data.C;
A = rotor_data.A;

if nargin == 4
x0 = zeros(1,6);
end

% Initialize output and states based on input parameters
output.clean = zeros(length(time), size(C, 1));
output.real = zeros(length(time), size(C, 1));
output.filtered = zeros(length(time), size(C, 1));
output.running = zeros(length(time), size(C, 1));%RUNNING

state.clean = zeros(length(time), size(A, 1));
state.real = zeros(length(time), size(A, 1));
state.estimate = zeros(length(time), size(A, 1));
state.running = zeros(length(time), size(A, 1));%RUNNING

% Simulate the system dynamics over the specified time

% Set initial state
state.clean(1, :) = x0; 
state.real(1, :) = x0; 
state.estimate(1, :) = x0;
state.running(1, :) = x0;%RUNNING

output.clean(1, :) = C*state.clean(1, :)';
output.real(1, :) = output.clean(1, :);
output.filtered(1, :) = output.clean(1, :);
output.running(1, :) = output.clean(1, :);%RUNNING

% Filter data

P = eye(6); % Initial Uncertainty
% Q: Process Noise Covariance (Trust in Physics)
% We use a small value to allow the model to drive the smoothness
Q = eye(6) * (0.003^2); 
% R: Measurement Noise Covariance (Trust in Sensors)
% We set this higher than actual noise to filter out the jitters
R = eye(3) * (0.01^2);

% Running 
window_size = 10; % You can adjust this window size

for t = 2:length(time)

%%% Perfect simulation

% update theta
theta_clean = state.clean(t - 1, 5);

% Update states based on linear dynamics, this works for everything
% except dx and dy
delta_x_clean(1) = state.clean(t - 1, 2)*dt;
delta_x_clean(3) = state.clean(t - 1, 4)*dt;
delta_x_clean(5) = state.clean(t - 1, 6)*dt;
delta_x_clean(6) = (r / I * control_input(t, 1) - r / I * control_input(t, 2)) * dt;

% Now, non-linear part
delta_x_clean(2) = (-sin(theta_clean)*(control_input(t, 1)+control_input(t, 2))/m) * dt;
delta_x_clean(4) = (cos(theta_clean)*(control_input(t, 1)+control_input(t, 2))/m - g) * dt;


% Lastly, updating states
state.clean(t, :) = state.clean(t-1, :) + delta_x_clean(:)';
output.clean(t, :) = (C * state.clean(t, :)')';

%%% Real-world simulation

% update theta
theta_real = state.real(t - 1, 5);

% Update states based on linear dynamics, this works for everything
% except dx and dy
delta_x_real(1) = state.real(t - 1, 2)*dt;
delta_x_real(3) = state.real(t - 1, 4)*dt;
delta_x_real(5) = state.real(t - 1, 6)*dt;
delta_x_real(6) = (r / I * control_input(t, 1) - r / I * control_input(t, 2)) * dt;

% Now, non-linear part
delta_x_real(2) = (-sin(theta_real)*(control_input(t, 1)+control_input(t, 2))/m) * dt;
delta_x_real(4) = (cos(theta_real)*(control_input(t, 1)+control_input(t, 2))/m - g) * dt;

% getting all the noise characteristics
state_noise = noise_data.state_noise_amp * randn(1, size(A, 1));
output_noise = noise_data.output_noise_amp * randn(1, size(C, 1));

state.real(t, :) = state.real(t - 1, :) + delta_x_real(:)' + state_noise;
output.real(t, :) = (C*state.real(t, :)')' + output_noise;

%%% Filter
% Filter uses perfect physics and sensor measurements, but we do not pass
% real state to it.

% PREDICTION STEP

% update theta
theta_estimate = state.estimate(t - 1, 5);

% Update states based on linear dynamics, this works for everything
% except dx and dy
delta_x_estimate(1) = state.estimate(t - 1, 2)*dt;
delta_x_estimate(3) = state.estimate(t - 1, 4)*dt;
delta_x_estimate(5) = state.estimate(t - 1, 6)*dt;
delta_x_estimate(6) = (r / I * control_input(t, 1) - r / I * control_input(t, 2)) * dt;

% Now, non-linear part
delta_x_estimate(2) = (-sin(theta_estimate)*(control_input(t, 1)+control_input(t, 2))/m) * dt;
delta_x_estimate(4) = (cos(theta_estimate)*(control_input(t, 1)+control_input(t, 2))/m - g) * dt;

state.estimate(t, :) = state.estimate(t - 1, :) + delta_x_estimate(:)';

% Predict covariance

F = eye(6) + dt * [0 1 0 0 0 0;
0 0 0 0 -cos(theta_estimate)*(control_input(t, 1)+control_input(t, 2))/m 0;
0 0 0 1 0 0;
0 0 0 0 -sin(theta_estimate)*(control_input(t, 1)+control_input(t, 2))/m 0;
0 0 0 0 0 1;
0 0 0 0 0 0];

P_prediction = F * P * F' + Q;

% CORRECTION STEP

% 1. Calculate Measurement Residual 
measurement_residual = output.real(t, :)' - C * state.estimate(t, :)';
measurement_residual(2) = mod(measurement_residual(2) + pi, 2*pi) - pi;

% 2. Calculate Kalman Gain
S = C * P_prediction * C' + R;
K = P_prediction * C' / S;

% 3. Update State Estimate
state.estimate(t, :) = state.estimate(t, :) + (K * measurement_residual)';
output.filtered(t, :) = C * state.estimate(t, :)';

% 4. Update Covariance
P = (eye(6) - K * C) * P_prediction;


% RUNNING 
% Determine the start of the window
window_start = max(1, t - window_size);

% Average the noisy measurements ('real' outputs) over the window
output.running(t, :) = mean(output.real(window_start:t, :), 1);

% update theta
theta_running = output.running(t, 2);

state.running(t, 3) = output.running(t, 1); % Overwrite y (State 3)
state.running(t, 5) = output.running(t, 2); % Overwrite theta (State 5)
state.running(t, 6) = output.running(t, 3); % Overwrite theta_dot (State 6)

% For the states, we apply the same averaging to the noisy running states
% Update states based on linear dynamics, this works for everything
% except dx and dy
delta_x_running(1) = state.running(t-1, 2) * dt;

% Now, non-linear part
delta_x_running(2) = (-sin(theta_running)*(control_input(t, 1)+control_input(t, 2))/m) * dt;
delta_x_running(4) = (cos(theta_running)*(control_input(t, 1)+control_input(t, 2))/m - g) * dt;

state.running(t, [1 2 4]) = state.running(t - 1, [1 2 4]) + delta_x_running([1 2 4]);

end


%RUNNING
errors.output_clean_VS_running_total = output.running - output.clean;
errors.states_real_VS_running = state.real - state.running;

errors.output_clean_VS_real_total = output.real - output.clean;
errors.output_clean_VS_filtered_total = output.filtered - output.clean;
errors.output_real_VS_filtered_total = output.filtered - output.real;

errors.states_clean_VS_real_total = state.real - state.clean;
errors.states_real_VS_estimate = state.real - state.estimate;
errors.state_real_VS_output_real = output.real - state.real(:, [3, 5, 6]);
errors.state_real_VS_output_filtered = output.filtered - state.real(:, [3, 5, 6]);

% Calculate the Mean Squared Error for each column (state variable)
num_states = size(errors.states_real_VS_estimate, 2);
rmse_values = zeros(1, num_states);
rmse_running = zeros(1, num_states);


for i = 1:num_states
% RMSE = sqrt(mean(error^2))
rmse_values(i) = sqrt(mean(errors.states_real_VS_estimate(:, i).^2));
%RUNNING
rmse_running(i) = sqrt(mean(errors.states_real_VS_running(:, i).^2));
end

rmse_unfiltered = zeros(1, 3);

for i = 1:3
rmse_unfiltered(i) = sqrt(mean(errors.state_real_VS_output_real(:, i).^2));
end

% Store the RMSE values in the errors structure

% state variables are typically: [x, dx, y, dy, theta, dtheta]
errors.rmse_states = rmse_values;
%RUNNING
errors.rmse_running = rmse_running;

errors.rmse_unfiltered = rmse_unfiltered;
end
	\end{lstlisting}
	
	\section{robustness.m}
	\begin{lstlisting}[style=MyMatlabStyle]
function [rmse_matrix, noise_matrix, divergence_data, rmse_matrix_running] = robustness(rotor_data, control_input, time, initial_state, noise_data_base)
% ROBUSTNESS - Run robustness tests and return data for plotting
% Returns: rmse_matrix (Kalman), noise_matrix, divergence_data, rmse_matrix_running (Running)

fprintf('\n=== Running Robustness Analysis ===\n');

% Define 4 noise cases (Cases 1-4)
noise_cases = [
0.0015, 0.01; % Case 1: Optimal
0.003,  0.02; % Case 2: Regular
0.015,  0.1;  % Case 3: High noise
0.03,   0.2   % Case 4: Very high noise
];

num_cases = size(noise_cases, 1);
rmse_matrix = zeros(num_cases, 6);
rmse_matrix_running = zeros(num_cases, 6); % NEW: Store running filter RMSE
noise_matrix = noise_cases;

% Run simulations for Cases 1-4
for case_num = 1:num_cases
noise_data.state_noise_amp = noise_cases(case_num, 1);
noise_data.output_noise_amp = noise_cases(case_num, 2);

[~, ~, errors] = simulation_quadrotor(rotor_data, control_input, noise_data, time, initial_state);

rmse_matrix(case_num, :) = errors.rmse_states;
rmse_matrix_running(case_num, :) = errors.rmse_running; % NEW

fprintf('Case %d RMSE (Kalman): ', case_num);
fprintf('%.4f ', errors.rmse_states);
fprintf('\n');
end

% Run divergence analysis
divergence_data = find_divergence_individual_states(rotor_data, control_input, time, initial_state, noise_data_base);

fprintf('\n=== Analysis Complete === \n');
end

%% ================= HELPER FUNCTION - TRACKS INDIVIDUAL STATE DIVERGENCE =================
function div_data = find_divergence_individual_states(rotor_data, control_input, time, initial_state, noise_data_base)
base_noise = [noise_data_base.state_noise_amp, noise_data_base.output_noise_amp]; % Base noise levels
max_multiplier = 50;
multiplier = 0.2; 

div_data.multipliers = [];
div_data.rmse_values = [];          % Kalman RMSE history
div_data.rmse_values_running = [];  % NEW: Running RMSE history

% State names
state_names = {'x', 'dx', 'y', 'dy', 'theta', 'dtheta'};
display_names = {'x', 'dx', 'y', 'dy', 'θ', 'dθ'};
div_data.state_names = state_names;
div_data.display_names = display_names;

% Initialize divergence tracking for BOTH filters
for i = 1:6
% Kalman Tracking
div_data.(['div_point_' state_names{i}]) = 0;
div_data.(['actually_diverged_' state_names{i}]) = false;
div_data.(['threshold_' state_names{i}]) = 0;

% NEW: Running Filter Tracking
div_data.(['div_point_running_' state_names{i}]) = 0;
div_data.(['actually_diverged_running_' state_names{i}]) = false;
end

% Thresholds (Shared between filters)
thresholds = [5.0, 1.0, 0.2, 0.2, 0.2, 0.1];  
for i = 1:6
div_data.(['threshold_' state_names{i}]) = thresholds(i);
end

fprintf('\n--- Starting Dual-Filter Divergence Analysis ---\n');

iteration = 0;
while multiplier <= max_multiplier
iteration = iteration + 1;
noise_data.state_noise_amp = base_noise(1) * multiplier;
noise_data.output_noise_amp = base_noise(2) * multiplier;

[~, ~, errors] = simulation_quadrotor(rotor_data, control_input, noise_data, time, initial_state);

div_data.multipliers(end+1) = multiplier;
div_data.rmse_values(end+1, :) = errors.rmse_states;
div_data.rmse_values_running(end+1, :) = errors.rmse_running; % NEW

% Check EACH STATE for divergence (Kalman & Running)
for state_idx = 1:6
threshold = thresholds(state_idx);
s_name = state_names{state_idx};

% 1. Check Kalman
if errors.rmse_states(state_idx) > threshold
if ~div_data.(['actually_diverged_' s_name])
div_data.(['actually_diverged_' s_name]) = true;
div_data.(['div_point_' s_name]) = multiplier;
fprintf('  [Kalman]  %s diverged at %.1fx\n', display_names{state_idx}, multiplier);
end
end

% 2. Check Running (NEW)
if errors.rmse_running(state_idx) > threshold
if ~div_data.(['actually_diverged_running_' s_name])
div_data.(['actually_diverged_running_' s_name]) = true;
div_data.(['div_point_running_' s_name]) = multiplier;
fprintf('  [Running] %s diverged at %.1fx\n', display_names{state_idx}, multiplier);
end
end
end

% Progress
if mod(iteration, 10) == 0
fprintf('  Progress: %.1f/%.1f\n', multiplier, max_multiplier);
end

% Early exit: Only if BOTH filters have failed on ALL states
all_diverged = true;
for state_idx = 1:6
s_name = state_names{state_idx};
if ~div_data.(['actually_diverged_' s_name]) || ~div_data.(['actually_diverged_running_' s_name])
all_diverged = false;
break;
end
end

if all_diverged
fprintf('  All states in both filters diverged. Stopping.\n');
break;
end

multiplier = multiplier + 0.2;
end

% Cleanup: Set stable states to max_tested
max_tested = max(div_data.multipliers);
div_data.max_multiplier_tested = max_tested;

for state_idx = 1:6
s_name = state_names{state_idx};
if ~div_data.(['actually_diverged_' s_name])
div_data.(['div_point_' s_name]) = max_tested;
end
if ~div_data.(['actually_diverged_running_' s_name])
div_data.(['div_point_running_' s_name]) = max_tested;
end
end
end
	\end{lstlisting}
	
\end{document}
