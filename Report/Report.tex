\documentclass{turabian-researchpaper}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{amsmath, amssymb, amsfonts} % For math equations
\usepackage{csquotes, ellipsis}
\usepackage[scaled=0.85]{beramono}
\usepackage{xcolor}     % For code coloring
\usepackage[numbered,framed]{matlab-prettifier} 
\usepackage{listings}   % For code snippets

\usepackage{graphicx}   % For images
\usepackage{float}      % For figure placement

\usepackage[notes, backend=biber]{biblatex-chicago}
\addbibresource{works-cited.bib}

% Specify paper size
\usepackage[pass, letterpaper]{geometry}

% Code Listing Style Definition
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

% --- Title Page Setup ---
\title{Planar Quadrotor}
\subtitle{Extended Kalman Filter Design}
\author{Arseni Lysak, Tsimafei Iliusenka, John Elvin Ndahiro, Pablo Calderon Mateo}

\course{Aeronautical Systems Integration}

\date{\today}

\begin{document}
	\maketitle
	
	\section{Introduction}
	
	The aim of this project is to implement an Extended Kalman Filter (EKF) to estimate the movement of a 2D planar quadrotor (fig. \ref{fig:quadrotor_diagram}) utilizing noisy sensor measurements.
	 
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.8\textwidth]{Planar_Quadrotor.png}
		\caption{Diagram of the Planar Quadrotor System.}
		\label{fig:quadrotor_diagram}
	\end{figure}
	
	\section{System modeling}
	
	The movement of the quadrotor is governed by the following nonlinear equations of motion:

\begin{align}
	m\ddot{x} &= -(u_1 + u_2)\sin\theta \label{eq:x_dyn} \\
	m\ddot{y} &= (u_1 + u_2)\cos\theta - mg \label{eq:y_dyn} \\
	I\ddot{\theta} &= r(u_1 - u_2) \label{eq:theta_dyn}
\end{align}
	
	\noindent where:
	\begin{itemize}
		\item $m$: mass of the quadrotor
		\item $I$: moment of inertia
		\item $r$: distance from the center of mass to the rotors
		\item $g$: gravitational acceleration
		\item $u_1, u_2$: rotor thrust forces
	\end{itemize}
	
	This would imply that the system state is represented by a six-element vector $\mathbf{x}$, and the control input is represented by a two-element vector $\mathbf{u}$:

	\begin{equation}
		\mathbf{x} = 
		\begin{bmatrix}
			x \\ \dot{x} \\ y \\ \dot{y} \\ \theta \\ \dot{\theta}
		\end{bmatrix}, \quad
		\mathbf{u} = 
		\begin{bmatrix}
			u_1 \\ u_2
		\end{bmatrix}
	\end{equation}
	
	\section{Quadcopter definition}
	
	The drone parameters were assumed:
	
	\begin{lstlisting}[style=Matlab-editor]
	m = 0.5;         % mass [kg] 
	r = 0.15;        % distance from center to rotors [m]
	I = 0.005;       % moment of inertia [kg*m^2]
	g = 9.81;        % gravity [m/s^2]
	dt = 0.01;       % time step [s] 
	theta = 0;       % angle [rads]
	u1 = 5;          % force [N]
	u2 = 5;          % force [N]
	\end{lstlisting}
	
	Four scenarios for control inputs were chosen:
	
	\begin{lstlisting}[style=Matlab-editor]
	% Create CU1 and CU2 (basic case)
	CU1 = u1 * 0.6 * (1 + 0.001*cos(2*time));  
	CU2 = u2 * 0.6 * (1 + 0.001*sin(2*time));
	
	% Create CU3 and CU4 (horizontal flight recovery)
	CU3 = zeros(size(time));
	CU4 = zeros(size(time));
	
	for t = 0:109 % roll up
	CU3(t + 1) = 4.05 * (1 + 0.001*cos(2 * 0.01 * t));
	CU4(t + 1) = 4 * (1 + 0.001*sin(2 * 0.01 * t));
	end
	for t = 110:219  % stop rotation
	CU3(t + 1) = 4 * (1 + 0.001*cos(2 * 0.01 * t));
	CU4(t + 1) = 4.05 * (1 + 0.001*sin(2 * 0.01 * t));
	end
	for t = 220:length(time) % fly up
	CU3(t + 1) = 4 * (1 + 0.001*cos(2 * 0.01 * t));
	CU4(t + 1) = 4 * (1 + 0.001*sin(2 * 0.01 * t));
	end
	
	% Create CU5 and CU6 (360 roll)
	CU5 = zeros(size(time));
	CU6 = zeros(size(time));
	
	for t = 0:199 % iniiate roll
	CU5(t + 1) = 4.04 * (1 + 0.001*cos(2 * 0.01 * t));
	CU6(t + 1) = 4 * (1 + 0.001*sin(2 * 0.01 * t));
	end 
	for t = 200:299 % let it roll
	CU5(t + 1) = 0 * (1 + 0.001*cos(2 * 0.01 * t));
	CU6(t + 1) = 0 * (1 + 0.001*sin(2 * 0.01 * t));
	end 
	for t = 300:500 % stop rotation
	CU5(t + 1) = 0 * (1 + 0.001*cos(2 * 0.01 * t));
	CU6(t + 1) = 0.04 * (1 + 0.001*sin(2 * 0.01 * t));
	end
	for t = 501:length(time) % recover vertically
	CU5(t + 1) = 5 * (1 + 0.001*cos(2 * 0.01 * t));
	CU6(t + 1) = 5 * (1 + 0.001*sin(2 * 0.01 * t));
	end 
	
	% Create CU7 and CU8 (straight fall recovery)
	CU7 = 3.2 * (1 + 0.001*cos(2*time));
	CU8 = 3.2 * (1 + 0.001*sin(2*time));
	
	% Combine for sim
	control_input.basic = [CU1; CU2]';
	control_input.horizontal = [CU3; CU4]';
	control_input.roll = [CU5; CU6]';
	control_input.fall = [CU7; CU8]';
	\end{lstlisting}
	
	A thrust generated by a rotor is inherently periodic an this is recreated using sine and cosine functions.


    \section{Clean simulation}
	
	Equations \ref{eq:x_dyn}-\ref{eq:theta_dyn} represent perfect conditions as they do not account for process noise. The state vector for this ideal trajectory is designated as \texttt{state.clean} in the code. This ensures the prediction adheres to the actual physical dynamics.
	
	Based on the equations \ref{eq:x_dyn}-\ref{eq:theta_dyn} Euler integration is conducted for each time step: 
	
	\begin{lstlisting}[style=Matlab-editor]
	% update theta
	theta_clean = state.clean(t - 1, 5);
	
	% Update states based on linear dynamics, this works for everything
	% except dx and dy
	delta_x_clean(1) = state.clean(t - 1, 2)*dt;
	delta_x_clean(3) = state.clean(t - 1, 4)*dt;
	delta_x_clean(5) = state.clean(t - 1, 6)*dt;
	delta_x_clean(6) = (r / I * control_input(t, 1) - r / I * control_input(t, 2)) * dt;
	
	% Now, non-linear part
	delta_x_clean(2) = (-sin(theta_clean)*(control_input(t, 1)+control_input(t, 2))/m) * dt;
	delta_x_clean(4) = (cos(theta_clean)*(control_input(t, 1)+control_input(t, 2))/m - g) * dt;
	
	% Lastly, updating states
	state.clean(t, :) = state.clean(t-1, :) + delta_x_clean(:)';
	output.clean(t, :) = (C * state.clean(t, :)')';
	\end{lstlisting}
	
	\section{Real-World Trajectory}
	
	The real-world trajectory (\texttt{state.real}) differs from the perfect trajectory solely through the introduction of process and measurement noise. Gaussian noise is utilized, with amplitudes selected as follows:
	
	\begin{lstlisting}[style=Matlab-editor]
	noise_data.state_noise_amp = 0.003;
	noise_data.output_noise_amp = 0.01;
	\end{lstlisting}
	
	The governing equations \ref{eq:x_dyn}-\ref{eq:theta_dyn} remain unchanged, with noise injected during the state update step:
	
	\begin{lstlisting}[style=Matlab-editor]
	state.real(t, :) = state.real(t - 1, :) + delta_x_real(:)' + state_noise;
	output.real(t, :) = (C*state.real(t, :)')' + output_noise;
	\end{lstlisting}
	
	\section{Extended Kalman Filter Design}
	
	The "default" Kalman filter addresses the general problem of trying to estimate the state of a discrete-time controlled process that is governed by a linear stochastic difference equation. A Kalman filter that linearizes about the current mean and covariance is referred to as an extended Kalman filter or EKF.
	
	The EKF is employed because the quadrotor system is nonlinear—motion is dependent on the sine and cosine of the angle $\theta$. The EKF linearizes the system at each time step using the current optimal estimate prior to applying standard Kalman update equations.
	
	The working principle of the filter is deciding how much to trust sensor measurements compared to the predicted values in accordance with the ideal mathematical model (fig. \ref{fig:ekfprinciple}).
		
	\begin{figure}
		\centering
		\includegraphics[width=1\linewidth]{ASI_EKFprinciple}
		\caption{A complete picture of the operation of the extended Kalman filter.}
		\label{fig:ekfprinciple}
	\end{figure}
	
	
	\subsection{Jacobian for Covariance Propagation}
	
	\noindent To estimate a process with non-linear difference and measurement relationships, it is possible to begin by writing new governing equations that linearize an estimate about the point k,
	\begin{align}
		x_k &\approx \tilde{x}_k + A(x_{k-1} - \hat{x}_{k-1}) + w_{k-1}, \label{eq:x_k}\\
		z_k &\approx \tilde{z}_k + H(x_k - \tilde{x}_k) + v_k \label{eq:z_k}
	\end{align}
	where
	\begin{itemize}
		\item $x_k$ and $z_k$ are the actual state and measurement vectors,
		\item $\tilde{x}_k$ and $\tilde{z}_k$ are the approximate state and measurement vectors
		\item $\hat{x}_k$ is an \textit{aposteriori} estimate of the state at step $k$,
		\item the random variables $w_k$ and $v_k$ represent the process and measurement noise
		\item $A$ is the Jacobian matrix of partial derivatives of $f$ with respect to $x$, that is
		\[
		A_{[i, j]} = \frac{\partial f_{[i]}}{\partial x_{[j]}}(\hat{x}_{k-1}, u_k, 0),
		\]
		\item $H$ is the Jacobian matrix of partial derivatives of $h$ with respect to $x$,
		\[
		H_{[i, j]} = \frac{\partial h_{[i]}}{\partial x_{[j]}}(\tilde{x}_k, 0),
		\]
	\end{itemize}
	
	
	The Extended Kalman Filter propagates uncertainty (covariance) by requiring a local linear approximation of the nonlinear dynamics in the form of matrices $A$ and $H$.
	
	To update the error covariance, the state transition Jacobian $A$ is derived from the partial derivatives of the dynamics, which are defined by equations \ref{eq:x_dyn} - \ref{eq:theta_dyn}:
	\begin{align}
		\frac{\partial \ddot{x}}{\partial \theta} = -\frac{\cos\theta}{m}(u_1 + u_2) \label{eq:partial_x} \\
		\frac{\partial \ddot{y}}{\partial \theta} = -\frac{\sin\theta}{m}(u_1 + u_2) \label{eq:partial_y}
	\end{align}

	
	The resulting Jacobian $A$ is:
	
	\begin{equation}
		A = \begin{bmatrix}
			0 & 1 & 0 & 0 & 0 & 0 \\
			0 & 0 & 0 & 0 & \frac{-\cos(\theta)(u_1+u_2)}{m} & 0 \\
			0 & 0 & 0 & 1 & 0 & 0 \\
			0 & 0 & 0 & 0 & \frac{-\sin(\theta)(u_1+u_2)}{m} & 0 \\
			0 & 0 & 0 & 0 & 0 & 1 \\
			0 & 0 & 0 & 0 & 0 & 0
		\end{bmatrix}
	\end{equation}
	
	The discrete-time state transition matrix $F$ used in the EKF is defined as $F = I + A \Delta t$, where $I$ represents the identity matrix and $A \Delta t$ represents the change over the time step.
	
	\begin{equation}
		F = \begin{bmatrix} 
			1 & \Delta t & 0 & 0 & 0 & 0 \\
			0 & 1 & 0 & 0 & \frac{-\cos(\theta)(u_1+u_2)}{m} \Delta t & 0 \\
			0 & 0 & 1 & \Delta t & 0 & 0 \\
			0 & 0 & 0 & 1 & \frac{-\sin(\theta)(u_1+u_2)}{m} \Delta t & 0 \\
			0 & 0 & 0 & 0 & 1 & \Delta t \\
			0 & 0 & 0 & 0 & 0 & 1 \\
		\end{bmatrix}
	\end{equation}
	
	The measurement matrix $H$ (referred to as $C$ in code) is defined as:
	
	\begin{equation}
		H = C = \begin{bmatrix}
			0 & 0 & 1 & 0 & 0 & 0 \\
			0 & 0 & 0 & 0 & 1 & 0 \\
			0 & 0 & 0 & 0 & 0 & 1
		\end{bmatrix}
	\end{equation}
	
	The implementation follows a standard \textbf{predict–correct cycle} (fig. \ref{fig:ekfprinciple}), executing in real-time within the simulation loop.
	
	\subsection{Prediction Step}
	
	First, the states are updated, and the estimate is stored as \texttt{state.estimate}.
		
	Following the state acquisition for the current timestep, the $F$ matrix is updated based on the current angle (\texttt{theta\_estimate}) and thrust (\texttt{control\_input}). This dependency characterizes the Extended Kalman Filter. The error covariance is then predicted:
	
	\begin{equation}
		P_k^- = A_k P_{k-1} A_k^T + W_k Q_{k-1} W_k^T 
	\end{equation}
	
	where $Q$ represents the confidence in the physics model.
	
	\subsection{Correction Step}
	The estimate is subsequently corrected using the latest noisy sensor data (\texttt{output.real}). The measurement residual—the discrepancy between sensor readings and predictions—is computed:
	
	\begin{lstlisting}[style=Matlab-editor]
	measurement_residual = output.real(t,:)' - C * state.estimate(t,:)';
	\end{lstlisting}
	
	The Kalman gain $K$ is calculated to determine the weighting between sensor data and physics predictions:
	\begin{align}
		S &= C P_k^- C^T + R \\
		K &= P_k^- C^T S^{-1}
	\end{align}
	
	Process noise covariance Q and measurement noise covariance R were defined as functions of noise amplitude. Normally, such data would not be accessible, but since an attempt to test EKF's capabilities is made, such decision is appropriate.
	
	Finally, the state and covariance are updated:
	
	\begin{lstlisting}[style=Matlab-editor]
	state.estimate(t,:) = state.estimate(t,:) + (K * measurement_residual)';
	P = (eye(6) - K * C) * P_prediction;
	\end{lstlisting}
	
	\section{Running Mean Filter}
	
	In order to compare the performance of the EKF, the running mean filter was implemented. With the window size of 10, it simply averages the values from the last 10 time steps when processing sensor measurements. It then uses this data, to predict the change in states.
	
	\begin{lstlisting}[style=Matlab-editor]
	% Determine the start of the window
	window_start = max(1, t - window_size);
	
	% Average the noisy measurements ('real' outputs) over the window
	output.running(t, :) = mean(output.real(window_start:t, :), 1);
	
	% update theta
	theta_running = output.running(t, 2);
	
	state.running(t, 3) = output.running(t, 1); % Overwrite y (State 3)
	state.running(t, 5) = output.running(t, 2); % Overwrite theta (State 5)
	state.running(t, 6) = output.running(t, 3); % Overwrite theta_dot (State 6)
	
	% For the states, we apply the same averaging to the noisy running states
	% Update states based on linear dynamics, this works for everything
	% except dx and dy
	delta_x_running(1) = state.running(t-1, 2) * dt;
	
	% Now, non-linear part
	delta_x_running(2) = (-sin(theta_running)*(control_input(t, 1)+control_input(t, 2))/m) * dt;
	delta_x_running(4) = (cos(theta_running)*(control_input(t, 1)+control_input(t, 2))/m - g) * dt;
	
	state.running(t, [1 2 4]) = state.running(t - 1, [1 2 4]) + delta_x_running([1 2 4]);
\end{lstlisting}

\section{MATLAB Implementation Breakdown}

The implementation is structured into three primary components:

\subsection{Main Script (Planar\_Quadrotor.m)}
This script defines the system parameters, invokes the simulation function, and generates final plots:

\begin{lstlisting}[style=Matlab-editor]
[state, output, errors] = simulation_quadrotor(rotor_data, control_input, noise_data, time, x0);
plot_quadrotor_results(time, state, output, rotor_data.C, errors);
	\end{lstlisting}
	
	\subsection{Core Simulation (simulation\_quadrotor.m)}
	This function executes three parallel simulations within a single loop, iterating time step by time step:
	\begin{itemize}
		\item \textbf{Clean trajectory (\texttt{state.clean}):} Utilizes true nonlinear dynamics without noise (Perfect Conditions).
		\item \textbf{Real-world trajectory (\texttt{state.real}):} Incorporates process noise into the state update and measurement noise into the outputs.
		\item \textbf{EKF estimate (\texttt{state.estimate}):} Runs the EKF in real-time:
		\begin{itemize}
			\item Predicts the next state using nonlinear physics.
			\item Constructs the Jacobian $F$ matrix using the current estimated angle and thrust.
			\item Corrects the estimate using noisy measurements.
			\item Updates covariance utilizing defined $Q$ and $R$ matrices.
		\end{itemize}
	\end{itemize}
	
	\subsection{Plotting Function (plot\_quadrotor\_results.m)}
	Generates figures comparing Perfect Conditions, noisy measurements, and EKF estimates for all measured states.
	
	\section{Results \& Visualization}
	
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.9\textwidth]{Measured_state.png}
		\caption{Measured States: Perfect Conditions vs. Noisy vs. EKF.}
		\label{fig:measured_states}
	\end{figure}
	
	\noindent The EKF successfully mitigates sensor noise while maintaining close tracking of the true trajectory. Although the raw data (red dots) exhibits significant variance due to measurement noise (0.05), the EKF estimate (green line) remains stable.
	
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.9\textwidth]{Full_state.png}
		\caption{Full State Estimation: Perfect Conditions vs. EKF.}
		\label{fig:full_state}
	\end{figure}
	
	\noindent Unmeasured states, including horizontal position ($x$) and velocities ($\dot{x}, \dot{y}$), are accurately reconstructed. This reconstruction is enabled by dynamic coupling: thrust influences both $y$ and $\theta$, which indirectly informs $x$-motion through the $\sin\theta$ and $\cos\theta$ terms.
	
\end{document}